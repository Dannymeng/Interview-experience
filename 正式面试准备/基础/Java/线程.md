## 实现线程的三种方式

创建线程的方式
- 继承Thread类
- 实现Runnable接口创建线程
- 使用Callable和Future创建线程


### 继承Thread类

看jdk源码可以发现，Thread类其实是实现了Runnable接口的一个实例，继承Thread类后需要重写run方法并通过start方法启动线程。继承Thread类耦合性太强了，因为java只能单继承，所以不利于扩展。

```java
  class Thread1 extends Thread {
        @Override
        public void run() {
            System.out.println("Thread1 is Running...");
        }
    }
```

### 实现Runnable接口

通过实现Runnable接口并重写run方法，并把Runnable实例传给Thread对象，Thread的start方法调用run方法再通过调用Runnable实例的run方法启动线程。所以如果一个类继承了另外一个父类，此时要实现多线程就不能通过继承Thread的类实现。
```java
 class Thread2 implements Runnable {
        @Override
        public void run() {
            System.out.println("Thread2 is Running...");
        }
    }
```

### 实现Callable接口

通过实现Callable接口并重写call方法，并把Callable实例传给FutureTask对象，再把FutureTask对象传给Thread对象。它与Thread、Runnable最大的不同是Callable能返回一个异步处理的结果Future对象并能抛出异常，而其他两种不能。

```java
 class Thread3<T> implements Callable<T> {
        @SuppressWarnings("unchecked")
        @Override
        public T call() throws Exception {
            System.out.println("Thread3 is Running...");
            return (T) new User("jiao", 23);
        }
    }

```

由于上述两种创建线程的方式无法保证获取之前的而执行结果，通过实现Callback接口，并用Future可以接收多线程的执行结果。

Future类存在于JDK的concurrent包中，主要用途是接受Java的异步线程计算返回结果。

举个例子：比如去吃早点时，点了包子和凉菜，包子需要等3分钟，凉菜只需1分钟，如果是串行的一个执行，在吃上早点的时候需要等待4分钟，但是因为你在等包子的时候，可以同时准备凉菜，所以在准备凉菜的过程中，可以同时准备包子，这样只需要等待3分钟。那Future这种模式就是后面这种执行模式。

[🔍 | Future对象](https://www.cnblogs.com/jcjssl/p/9592145.html)

## 关闭线程的三种方式
使用run方法执行完毕之后，该线程就终止了。但是在某些特殊情形下，run()方法会被一直执行，比如使用**while(true){...}**这样的循环语句。

- 使用标志位终止线程
- 使用stop()终止线程（过时）
- 使用interrupt()中断线程

### 使用标志位终止线程
修改标志位的方式结束run（）方法

```java
public class ServerThread extends Thread {
    //volatile修饰符用来保证其它线程读取的总是该变量的最新的值
    public volatile boolean exit = false; 

    @Override
    public void run() {
        ServerSocket serverSocket = new ServerSocket(8080);
        while(!exit){
            serverSocket.accept(); //阻塞等待客户端消息
            ...
        }
    }
    
    public static void main(String[] args) {
        ServerThread t = new ServerThread();
        t.start();
        ...
        t.exit = true; //修改标志位，退出线程
    }
}

```


### 使用stop()终止线程
使用stop()方法确实可以终止线程，但是java.lang.Thread中除了start()方法外，stop(), resume(), suspend(), destory()等方法已经过时（deprecated）

为什么弃用stop：
 - 调用stop方法会立即停止run()方法中剩余的全部工作，包括catch或finally语句中的，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。
 - 调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。

### 使用interrupt()中断线程

现在我们知道了使用 stop() 方式停止线程是非常不安全的方式，那么我们应该使用什么方法来停止线程呢？答案就是使用 interrupt() 方法来中断线程。

调用 interrupt() 方法仅仅是在当前线程中打一个停止的标记，并不是真的停止线程。

也就是说，线程中断并不会立即终止线程，而是通知目标线程，有人希望你终止。至于目标线程收到通知后会如何处理，则完全由目标线程自行决定。这一点很重要，如果中断后，线程立即无条件退出，那么我们又会遇到 stop() 方法的老问题。

```java
public class demo5 extends Thread {
    
    public static void main(String[] args) {
        try {
            demo5 t = new demo5();
            t.start();
            Thread.sleep(200);
            t.interrupt();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        super.run();
        for (int i = 0; i <= 200000; i++) {
            //判断是否被中断
            if (Thread.currentThread().isInterrupted()) {
                //处理中断逻辑
                break;
            }
            System.out.println("i=" + i);
        }
    }
}
```

**注意：** 如果希望线程t在中断后停止，就必须先判断是否被中断，并为它增加相应的中断处理代码
```java
if(Thread.currentThread().isInterrupted()){
    //处理中断逻辑
    break;
}
```

这种方式看起来与之前介绍的“使用标志位终止线程”非常类似，**但是在遇到 sleep() 或者 wait() 这样的操作，我们只能通过中断来处理了**。

`public static native void sleep(long millis) throws InterruptedException`

Thread.sleep() 方法会抛出一个 InterruptedException 异常，当线程被 sleep() 休眠时，如果被中断，这会就抛出这个异常。

Thread.sleep() 方法由于中断而抛出的异常，是会清除中断标记的。

[🔍 | Java终止线程的三种方式](https://www.cnblogs.com/liyutian/p/10196044.html)


