{"compress":true,"commitItems":[["2f4d95d4-8c87-43f0-8624-7495e1dc9be5",1553407710138,"",[[1553407658123,["28447@DESKTOP-BE7HQ26",[[1,0,"# Java知识点\n\n\n\n"]],[0,0],[12,12]]],[1553407660156,["28447@DESKTOP-BE7HQ26",[[-1,12,"\n"],[1,13,"#"]],[12,12],[13,13]]],[1553407660299,["28447@DESKTOP-BE7HQ26",[[1,13,"3"]],[13,13],[14,14]]],[1553407660642,["28447@DESKTOP-BE7HQ26",[[1,14,"\n\n"]],[14,14],[15,15]]],[1553407661136,["28447@DESKTOP-BE7HQ26",[[-1,15,"\n"]],[15,15],[14,14]]],[1553407661313,["28447@DESKTOP-BE7HQ26",[[-1,13,"3"]],[14,14],[13,13]]],[1553407662430,["28447@DESKTOP-BE7HQ26",[[1,13,"#"]],[13,13],[14,14]]],[1553407662966,["28447@DESKTOP-BE7HQ26",[[1,15,"\n"]],[14,14],[15,15]]],[1553407678799,["28447@DESKTOP-BE7HQ26",[[1,14,"  集合线程"]],[14,14],[20,20]]],[1553407680379,["28447@DESKTOP-BE7HQ26",[[1,18,"、"]],[18,18],[19,19]]],[1553434415269,["28447@DESKTOP-BE7HQ26",[[1,23,"\n"]],[22,22],[23,23]]],[1553434415474,["28447@DESKTOP-BE7HQ26",[[1,24,"\n"]],[23,23],[24,24]]],[1553434415730,["28447@DESKTOP-BE7HQ26",[[1,25,"\n"]],[24,24],[25,25]]],[1553434415958,["28447@DESKTOP-BE7HQ26",[[1,26,"\n"]],[25,25],[26,26]]],[1553434416235,["28447@DESKTOP-BE7HQ26",[[-1,26,"\n"],[1,27,"1"]],[26,26],[27,27]]],[1553434416377,["28447@DESKTOP-BE7HQ26",[[1,27,"、"]],[27,27],[28,28]]],[1553434417844,["28447@DESKTOP-BE7HQ26",[[-1,27,"、"]],[28,28],[27,27]]],[1553434418704,["28447@DESKTOP-BE7HQ26",[[1,27,"、"]],[27,27],[28,28]]],[1553434429156,["28447@DESKTOP-BE7HQ26",[[1,28,"什么是一致性Hash算法"]],[28,28],[40,40]]],[1553434429742,["28447@DESKTOP-BE7HQ26",[[1,40,"\n\n"]],[40,40],[41,41]]],[1553434430593,["28447@DESKTOP-BE7HQ26",[[1,42,"\n"]],[41,41],[42,42]]],[1553434431288,["28447@DESKTOP-BE7HQ26",[[-1,42,"\n"],[1,43,"d"]],[42,42],[43,43]]],[1553434431370,["28447@DESKTOP-BE7HQ26",[[1,43,"a"]],[43,43],[44,44]]],[1553434432016,["28447@DESKTOP-BE7HQ26",[[-1,43,"a"]],[44,44],[43,43]]],[1553434432216,["28447@DESKTOP-BE7HQ26",[[-1,42,"d"],[1,43,"\n"]],[43,43],[42,42]]],[1553434432679,["28447@DESKTOP-BE7HQ26",[[-1,42,"\n"]],[42,42],[41,41]]],[1553434434496,["28447@DESKTOP-BE7HQ26",[[-1,41,"\n"],[1,42,"答"]],[41,41],[42,42]]],[1553434435267,["28447@DESKTOP-BE7HQ26",[[1,42,"："]],[42,42],[43,43]]],[1553435507735,["28447@DESKTOP-BE7HQ26",[[1,43,"1、"]],[43,43],[45,45]]],[1553435508806,["28447@DESKTOP-BE7HQ26",[[-1,43,"1、"]],[45,45],[43,43]]],[1553435509767,["28447@DESKTOP-BE7HQ26",[[1,43,"》"]],[43,43],[44,44]]],[1553435510608,["28447@DESKTOP-BE7HQ26",[[1,43,"1"]],[43,43],[44,44]]],[1553435512726,["28447@DESKTOP-BE7HQ26",[[-1,43,"1》"]],[45,45],[43,43]]],[1553435514375,["28447@DESKTOP-BE7HQ26",[[1,43,"）"]],[43,43],[44,44]]],[1553435515057,["28447@DESKTOP-BE7HQ26",[[1,43,"1"]],[43,43],[44,44]]],[1553435518510,["28447@DESKTOP-BE7HQ26",[[-1,42,"：1）"]],[45,45],[42,42]]],[1553435518693,["28447@DESKTOP-BE7HQ26",[[-1,41,"答"],[1,42,"\n"]],[42,42],[41,41]]],[1553435520335,["28447@DESKTOP-BE7HQ26",[[-1,41,"\n"],[1,42,"·"]],[41,41],[42,42]]],[1553435521293,["28447@DESKTOP-BE7HQ26",[[-1,41,"·"],[1,42,"\n"]],[42,42],[41,41]]],[1553435521764,["28447@DESKTOP-BE7HQ26",[[-1,41,"\n"],[1,42,"`"]],[41,41],[42,42]]],[1553435522925,["28447@DESKTOP-BE7HQ26",[[1,42," asjd "]],[42,42],[48,48]]],[1553435524853,["28447@DESKTOP-BE7HQ26",[[-1,42," asjd "]],[48,48],[42,42]]],[1553435525383,["28447@DESKTOP-BE7HQ26",[[-1,41,"`"],[1,42,"\n"]],[42,42],[41,41]]],[1553435525754,["28447@DESKTOP-BE7HQ26",[[-1,41,"\n"],[1,42,"-"]],[41,41],[42,42]]],[1553435527073,["28447@DESKTOP-BE7HQ26",[[1,42," asjd "]],[42,42],[48,48]]],[1553435528951,["28447@DESKTOP-BE7HQ26",[[-1,43,"asjd "]],[48,48],[43,43]]],[1553435545944,["28447@DESKTOP-BE7HQ26",[[1,43,"hash值是个整数非负，非负帧数"]],[43,43],[59,59]]],[1553435546695,["28447@DESKTOP-BE7HQ26",[[-1,57,"帧数"]],[59,59],[57,57]]],[1553435555045,["28447@DESKTOP-BE7HQ26",[[1,57,"整数的值范围"]],[57,57],[63,63]]],[1553435568920,["28447@DESKTOP-BE7HQ26",[[1,63,"做成一个圆环（）"]],[63,63],[71,71]]],[1553435570788,["28447@DESKTOP-BE7HQ26",[[1,70,"0-"]],[70,70],[72,72]]],[1553435573312,["28447@DESKTOP-BE7HQ26",[[-1,71,"-"]],[72,72],[71,71]]],[1553435577572,["28447@DESKTOP-BE7HQ26",[[1,71,"——2……3"]],[71,71],[77,77]]],[1553435578336,["28447@DESKTOP-BE7HQ26",[[-1,74,"……3"]],[77,77],[74,74]]],[1553435581784,["28447@DESKTOP-BE7HQ26",[[1,74,"^32-1"]],[74,74],[79,79]]],[1553435589894,["28447@DESKTOP-BE7HQ26",[[1,80,"\n- 对集群的系欸但"]],[80,80],[90,90]]],[1553435590763,["28447@DESKTOP-BE7HQ26",[[-1,87,"系欸但"]],[90,90],[87,87]]],[1553435600289,["28447@DESKTOP-BE7HQ26",[[1,87,"节点的某个属性（）"]],[87,87],[96,96]]],[1553435604993,["28447@DESKTOP-BE7HQ26",[[1,95,"比如系欸但"]],[95,95],[100,100]]],[1553435606209,["28447@DESKTOP-BE7HQ26",[[-1,97,"系欸但"]],[100,100],[97,97]]],[1553435609274,["28447@DESKTOP-BE7HQ26",[[1,97,"节点名"]],[97,97],[100,100]]],[1553435619500,["28447@DESKTOP-BE7HQ26",[[1,101,"求hash值，放在"]],[101,101],[110,110]]],[1553435640332,["28447@DESKTOP-BE7HQ26",[[1,110,"环上\n- 对数据key求hash值，也放在煌上"]],[110,110],[133,133]]],[1553435641171,["28447@DESKTOP-BE7HQ26",[[-1,131,"煌上"]],[133,133],[131,131]]],[1553435651523,["28447@DESKTOP-BE7HQ26",[[1,131,"环上，按照"]],[131,131],[136,136]]],[1553435652865,["28447@DESKTOP-BE7HQ26",[[-1,135,"照"]],[136,136],[135,135]]],[1553435660957,["28447@DESKTOP-BE7HQ26",[[1,135,"顺时针方向找到"]],[135,135],[142,142]]],[1553435799089,["28447@DESKTOP-BE7HQ26",[[1,142,"离它最经的"]],[142,142],[147,147]]],[1553435799586,["28447@DESKTOP-BE7HQ26",[[-1,145,"经的"]],[147,147],[145,145]]],[1553435801714,["28447@DESKTOP-BE7HQ26",[[1,145,"近的"]],[145,145],[147,147]]],[1553435811512,["28447@DESKTOP-BE7HQ26",[[1,147,"节点，放在它上面。"]],[147,147],[156,156]]],[1553435813556,["28447@DESKTOP-BE7HQ26",[[1,112,"；"]],[112,112],[113,113]]],[1553435815815,["28447@DESKTOP-BE7HQ26",[[1,80,"；"]],[80,80],[81,81]]],[1553435817489,["28447@DESKTOP-BE7HQ26",[[1,41,"\n"]],[40,40],[41,41]]],[1553435819489,["28447@DESKTOP-BE7HQ26",[[1,41,"yuan"]],[41,41],[45,45]]],[1553435820877,["28447@DESKTOP-BE7HQ26",[[-1,41,"yuan"]],[45,45],[41,41]]],[1553435821122,["28447@DESKTOP-BE7HQ26",[[-1,41,"\n"]],[41,41],[40,40]]],[1553435822529,["28447@DESKTOP-BE7HQ26",[[1,41,"\n"]],[40,40],[41,41]]],[1553435838130,["28447@DESKTOP-BE7HQ26",[[1,41,"原因：普通hash%"]],[41,41],[51,51]]],[1553435841938,["28447@DESKTOP-BE7HQ26",[[-1,50,"%"]],[51,51],[50,50]]],[1553435855855,["28447@DESKTOP-BE7HQ26",[[1,50,"取模的方式在增加系欸但"]],[50,50],[61,61]]],[1553435857138,["28447@DESKTOP-BE7HQ26",[[-1,58,"系欸但"]],[61,61],[58,58]]],[1553435860121,["28447@DESKTOP-BE7HQ26",[[1,58,"节点和"]],[58,58],[61,61]]],[1553435860638,["28447@DESKTOP-BE7HQ26",[[-1,60,"和"]],[61,61],[60,60]]],[1553435866442,["28447@DESKTOP-BE7HQ26",[[1,60,"或减少节点"]],[60,60],[65,65]]],[1553435873966,["28447@DESKTOP-BE7HQ26",[[1,65,"时"]],[65,65],[66,66]]],[1553435925986,["28447@DESKTOP-BE7HQ26",[[1,95,"``"]],[95,95],[97,97]]],[1553435928280,["28447@DESKTOP-BE7HQ26",[[1,96,"hash"]],[96,96],[100,100]]],[1553435931922,["28447@DESKTOP-BE7HQ26",[[-1,97,"ash"]],[100,100],[97,97]]],[1553435932140,["28447@DESKTOP-BE7HQ26",[[-1,96,"h"]],[97,97],[96,96]]],[1553435935523,["28447@DESKTOP-BE7HQ26",[[1,96,"Hash环"]],[96,96],[101,101]]],[1553435949982,["28447@DESKTOP-BE7HQ26",[[1,41,"\n"]],[40,40],[41,41]]],[1553435952447,["28447@DESKTOP-BE7HQ26",[[1,68,"\n"]],[67,67],[68,68]]],[1553435976573,["28447@DESKTOP-BE7HQ26",[[1,67,"，映射规则将被改变"]],[67,67],[76,76]]],[1553436001394,["28447@DESKTOP-BE7HQ26",[[1,78,"\n"]],[76,76],[77,77]]],[1553436002368,["28447@DESKTOP-BE7HQ26",[[1,77,"![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbhiae1AfNYAibdp7ib2wTZTrpz1ZyCTibgvW1H5TXzXDlQnuuNiaK0ce42zv6hz0L3rt2icZePaAmT4Ddw/640)"]],[77,77],[235,235]]],[1553436011065,["28447@DESKTOP-BE7HQ26",[[1,77,"\n"]],[76,76],[77,77]]],[1553436013170,["28447@DESKTOP-BE7HQ26",[[1,45,"\n"]],[45,45],[46,46]]],[1553436018542,["28447@DESKTOP-BE7HQ26",[[1,46,"应用上经"]],[46,46],[50,50]]],[1553436019172,["28447@DESKTOP-BE7HQ26",[[-1,48,"上经"]],[50,50],[48,48]]],[1553436032811,["28447@DESKTOP-BE7HQ26",[[1,48,"场景：redis缓存如果使用"]],[48,48],[62,62]]],[1553436040286,["28447@DESKTOP-BE7HQ26",[[1,73,"。"]],[73,73],[74,74]]],[1553436044285,["28447@DESKTOP-BE7HQ26",[[-1,58,"如果"]],[60,60],[58,58]]],[1553436047081,["28447@DESKTOP-BE7HQ26",[[1,58,"假设"]],[58,58],[60,60]]],[1553436055867,["28447@DESKTOP-BE7HQ26",[[1,94,"，"]],[94,94],[95,95]]],[1553436068112,["28447@DESKTOP-BE7HQ26",[[1,95,"当应用无法从换尺寸"]],[95,95],[104,104]]],[1553436070012,["28447@DESKTOP-BE7HQ26",[[-1,101,"换尺寸"]],[104,104],[101,101]]],[1553436071621,["28447@DESKTOP-BE7HQ26",[[1,101,"换粗"]],[101,101],[103,103]]],[1553436072279,["28447@DESKTOP-BE7HQ26",[[-1,101,"换粗"]],[103,103],[101,101]]],[1553436085802,["28447@DESKTOP-BE7HQ26",[[1,101,"缓存中获取数据，则会想后患"]],[101,101],[114,114]]],[1553436087321,["28447@DESKTOP-BE7HQ26",[[-1,112,"后患"]],[114,114],[112,112]]],[1553436096535,["28447@DESKTOP-BE7HQ26",[[1,112,"后端数据库请求数据"]],[112,112],[121,121]]],[1553436101810,["28447@DESKTOP-BE7HQ26",[[1,407,"\n- "]],[407,407],[410,410]]],[1553436101995,["28447@DESKTOP-BE7HQ26",[[-1,408,"- "],[1,410,"\n\n"]],[410,410],[409,409]]],[1553436103352,["28447@DESKTOP-BE7HQ26",[[-1,409,"\n"],[1,410,"`"]],[409,409],[410,410]]],[1553436103567,["28447@DESKTOP-BE7HQ26",[[1,410,"`"]],[410,410],[411,411]]],[1553436105762,["28447@DESKTOP-BE7HQ26",[[1,410,"附"]],[410,410],[411,411]]],[1553436132897,["28447@DESKTOP-BE7HQ26",[[1,412," 如何保证"]],[412,412],[417,417]]],[1553436133455,["28447@DESKTOP-BE7HQ26",[[-1,415,"保证"]],[417,417],[415,415]]],[1553436135469,["28447@DESKTOP-BE7HQ26",[[1,415,"皮面"]],[415,415],[417,417]]],[1553436136197,["28447@DESKTOP-BE7HQ26",[[-1,415,"皮面"]],[417,417],[415,415]]],[1553436142760,["28447@DESKTOP-BE7HQ26",[[1,415,"避免Hashhua"]],[415,415],[424,424]]],[1553436143414,["28447@DESKTOP-BE7HQ26",[[-1,421,"hua"]],[424,424],[421,421]]],[1553436149226,["28447@DESKTOP-BE7HQ26",[[1,421,"环的数据倾斜"]],[421,421],[427,427]]],[1553436149507,["28447@DESKTOP-BE7HQ26",[[1,427,"\n\n"]],[427,427],[428,428]]],[1553436150581,["28447@DESKTOP-BE7HQ26",[[-1,428,"\n"]],[428,428],[427,427]]],[1553436151380,["28447@DESKTOP-BE7HQ26",[[1,427,"？"]],[427,427],[428,428]]],[1553436151557,["28447@DESKTOP-BE7HQ26",[[1,429,"\n"]],[428,428],[429,429]]],[1553436161460,["28447@DESKTOP-BE7HQ26",[[1,28,"****"]],[28,28],[30,30]]],[1553436163500,["28447@DESKTOP-BE7HQ26",[[-1,32,"什么是一致性Hash算法"]],[32,44],[32,32]]],[1553436164546,["28447@DESKTOP-BE7HQ26",[[1,30,"什么是一致性Hash算法"]],[30,30],[42,42]]],[1553436170054,["28447@DESKTOP-BE7HQ26",[[1,434,"\n"]],[432,432],[433,433]]],[1553436174419,["28447@DESKTOP-BE7HQ26",[[-1,26,"1、"]],[26,28],[26,26]]],[1553436176254,["28447@DESKTOP-BE7HQ26",[[1,26,"## "]],[26,26],[29,29]]],[1553436177732,["28447@DESKTOP-BE7HQ26",[[-1,28," "]],[29,29],[28,28]]],[1553436179322,["28447@DESKTOP-BE7HQ26",[[1,28,"# "]],[28,28],[30,30]]],[1553436208514,["28447@DESKTOP-BE7HQ26",[[1,437,"\n"]],[434,434],[435,435]]],[1553436224468,["28447@DESKTOP-BE7HQ26",[[1,436,"引入~~~~"]],[436,436],[440,440]]],[1553436225411,["28447@DESKTOP-BE7HQ26",[[-1,440,"~~"]],[440,440],[438,438]]],[1553436226935,["28447@DESKTOP-BE7HQ26",[[-1,438,"~~"]],[440,440],[438,438]]],[1553436227611,["28447@DESKTOP-BE7HQ26",[[1,438,"``"]],[438,438],[440,440]]],[1553436231109,["28447@DESKTOP-BE7HQ26",[[1,439,"虚拟系欸但"]],[439,439],[444,444]]],[1553436232027,["28447@DESKTOP-BE7HQ26",[[-1,441,"系欸但"]],[444,444],[441,441]]],[1553436235219,["28447@DESKTOP-BE7HQ26",[[1,441,"节点"]],[441,441],[443,443]]],[1553436250737,["28447@DESKTOP-BE7HQ26",[[1,444,"，例如将一个"]],[444,444],[450,450]]],[1553436252321,["28447@DESKTOP-BE7HQ26",[[-1,448,"一个"]],[450,450],[448,448]]],[1553436272315,["28447@DESKTOP-BE7HQ26",[[1,448,"每台服务器就算三个寻"]],[448,448],[458,458]]],[1553436272989,["28447@DESKTOP-BE7HQ26",[[-1,457,"寻"]],[458,458],[457,457]]],[1553436277843,["28447@DESKTOP-BE7HQ26",[[1,457,"虚拟节点，"]],[457,457],[462,462]]],[1553436286424,["28447@DESKTOP-BE7HQ26",[[1,462,"于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点："]],[462,462],[552,552]]],[1553436292076,["28447@DESKTOP-BE7HQ26",[[-1,551,"："]],[552,552],[551,551]]],[1553436298576,["28447@DESKTOP-BE7HQ26",[[-1,552,"\n"],[1,553,"【"]],[552,552],[553,553]]],[1553436299350,["28447@DESKTOP-BE7HQ26",[[-1,552,"【"],[1,553,"\n"]],[553,553],[552,552]]],[1553436299977,["28447@DESKTOP-BE7HQ26",[[-1,552,"\n"],[1,553,"p"]],[552,552],[553,553]]],[1553436300317,["28447@DESKTOP-BE7HQ26",[[-1,552,"p"],[1,553,"\n"]],[553,553],[552,552]]],[1553436300558,["28447@DESKTOP-BE7HQ26",[[-1,552,"\n"],[1,553,"["]],[552,552],[553,553]]],[1553436300791,["28447@DESKTOP-BE7HQ26",[[1,553,"]"]],[553,553],[554,554]]],[1553436304459,["28447@DESKTOP-BE7HQ26",[[1,553,"参考文章"]],[553,553],[557,557]]],[1553436305587,["28447@DESKTOP-BE7HQ26",[[1,558,"（"]],[558,558],[559,559]]],[1553436306347,["28447@DESKTOP-BE7HQ26",[[-1,558,"（"]],[559,559],[558,558]]],[1553436306888,["28447@DESKTOP-BE7HQ26",[[1,558,"("]],[558,558],[559,559]]],[1553436306924,["28447@DESKTOP-BE7HQ26",[[1,559,"https://)"]],[559,559],[559,567]]],[1553436307577,["28447@DESKTOP-BE7HQ26",[[1,567,"blog.csdn.net/bntX2jSQfEHy7/article/details/79549368"]],[559,567],[619,619]]],[1553436311296,["28447@DESKTOP-BE7HQ26",[[1,552,"\n"]],[552,552],[553,553]]],[1553437989603,["28447@DESKTOP-BE7HQ26",[[1,25,"### **什么是一致性Hash算法**\n"]],[24,24],[45,45]]],[1553437993187,["28447@DESKTOP-BE7HQ26",[[-1,31,"什么是一致性"]],[31,37],[31,31]]],[1553437996415,["28447@DESKTOP-BE7HQ26",[[-1,35,"算法"]],[37,37],[35,35]]],[1553437997926,["28447@DESKTOP-BE7HQ26",[[1,35,"ma"]],[35,35],[37,37]]],[1553437998267,["28447@DESKTOP-BE7HQ26",[[-1,36,"a"]],[37,37],[36,36]]],[1553437999562,["28447@DESKTOP-BE7HQ26",[[1,36,"map"]],[36,36],[39,39]]],[1553438001272,["28447@DESKTOP-BE7HQ26",[[-1,35,"mm"]],[37,37],[35,35]]],[1553438002590,["28447@DESKTOP-BE7HQ26",[[1,35,"M"]],[35,35],[36,36]]],[1553438006104,["28447@DESKTOP-BE7HQ26",[[1,38,"sh"]],[38,38],[40,40]]],[1553438006689,["28447@DESKTOP-BE7HQ26",[[-1,38,"sh"]],[40,40],[38,38]]],[1553438008730,["28447@DESKTOP-BE7HQ26",[[1,38,"实现原理"]],[38,38],[42,42]]],[1553438009720,["28447@DESKTOP-BE7HQ26",[[1,46,"\n"]],[44,44],[45,45]]],[1553438015094,["28447@DESKTOP-BE7HQ26",[[1,574,"\n"]],[573,573],[574,574]]],[1553438048875,["28447@DESKTOP-BE7HQ26",[[1,573,"![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbhiae1AfNYAibdp7ib2wTZTrpnNGzjcWYy3ylL7s1Bq2UKicU5mYG8SHsuIFTOf2PMe2FstpM2gMeQbw/640)"]],[573,573],[729,729]]]],null,"28447@DESKTOP-BE7HQ26"],["9dd86d06-6459-4876-acfd-38164e3aa53f",1553447681918,"# Java知识点\n\n\n##  集合、线程\n\n\n\n### **HashMap实现原理**\n\n\n### **什么是一致性Hash算法**\n\n原因：\n应用场景：redis缓存假设使用普通hash取模的方式。在增加节点或减少节点时，映射规则将被改变，当应用无法从缓存中获取数据，则会想后端数据库请求数据\n\n![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbhiae1AfNYAibdp7ib2wTZTrpz1ZyCTibgvW1H5TXzXDlQnuuNiaK0ce42zv6hz0L3rt2icZePaAmT4Ddw/640)\n\n- hash值是个整数非负，非负整数的值范围做成一个圆环`Hash环`（0——2^32-1）；\n- 对集群的节点的某个属性（比如节点名）求hash值，放在环上；\n- 对数据key求hash值，也放在环上，按顺时针方向找到离它最近的节点，放在它上面。\n\n`附` 如何避免Hash环的数据倾斜？\n\n引入`虚拟节点`，例如将每台服务器就算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点\n![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbhiae1AfNYAibdp7ib2wTZTrpnNGzjcWYy3ylL7s1Bq2UKicU5mYG8SHsuIFTOf2PMe2FstpM2gMeQbw/640)\n\n[参考文章](https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368)",[[1553447624740,["28447@DESKTOP-BE7HQ26",[[1,47,"\n"]],[44,44],[45,45]]],[1553447624870,["28447@DESKTOP-BE7HQ26",[[1,48,"\n"]],[45,45],[46,46]]],[1553447650810,["28447@DESKTOP-BE7HQ26",[[1,49,"\n"]],[46,46],[47,47]]],[1553447651020,["28447@DESKTOP-BE7HQ26",[[1,50,"\n"]],[47,47],[48,48]]],[1553447677004,["28447@DESKTOP-BE7HQ26",[[1,46,"HashMap的主干是一个Entry数组。"]],[46,46],[67,67]]],[1553447683488,["28447@DESKTOP-BE7HQ26",[[1,67,"Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。"]],[67,67],[113,113]]],[1553447685185,["28447@DESKTOP-BE7HQ26",[[1,118,"\n"]],[113,113],[114,114]]],[1553447694092,["28447@DESKTOP-BE7HQ26",[[1,114,"```"]],[114,114],[117,117]]],[1553447694119,["28447@DESKTOP-BE7HQ26",[[1,117,"language\n```\n"]],[117,117],[117,125]]],[1553447695238,["28447@DESKTOP-BE7HQ26",[[-1,117,"language"],[1,125,"j"]],[117,125],[118,118]]],[1553447696367,["28447@DESKTOP-BE7HQ26",[[1,118,"ava"]],[118,118],[121,121]]],[1553447696845,["28447@DESKTOP-BE7HQ26",[[1,122,"\n"]],[121,121],[122,122]]],[1553447698105,["28447@DESKTOP-BE7HQ26",[[1,122,"//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。\ntransient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;"]],[122,122],[255,255]]],[1553447708135,["28447@DESKTOP-BE7HQ26",[[1,265,"\n"]],[259,259],[260,260]]],[1553447708365,["28447@DESKTOP-BE7HQ26",[[1,266,"\n"]],[260,260],[261,261]]],[1553447918785,["28447@DESKTOP-BE7HQ26",[[1,267,"\n"]],[259,259],[260,260]]],[1553447919331,["28447@DESKTOP-BE7HQ26",[[1,268,"\n"]],[260,260],[261,261]]],[1553447935485,["28447@DESKTOP-BE7HQ26",[[1,262,"![](https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png)"]],[262,262],[357,357]]],[1553447942237,["28447@DESKTOP-BE7HQ26",[[1,364,"\n"]],[357,357],[358,358]]],[1553447942435,["28447@DESKTOP-BE7HQ26",[[1,365,"\n"]],[358,358],[359,359]]],[1553447949263,["28447@DESKTOP-BE7HQ26",[[1,359,"**简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。**"]],[359,359],[599,599]]],[1553448176798,["28447@DESKTOP-BE7HQ26",[[1,601,"[]"]],[601,601],[603,603]]],[1553448182272,["28447@DESKTOP-BE7HQ26",[[1,602,"参考资料"]],[602,602],[606,606]]],[1553448183547,["28447@DESKTOP-BE7HQ26",[[1,607,"("]],[607,607],[608,608]]],[1553448183583,["28447@DESKTOP-BE7HQ26",[[1,608,"https://)"]],[608,608],[608,616]]],[1553448184420,["28447@DESKTOP-BE7HQ26",[[1,616,"www.cnblogs.com/chengxiao/p/6059914.html"]],[608,616],[656,656]]]],null,"28447@DESKTOP-BE7HQ26"],["3e34a88c-079c-4a61-a25a-2b5b39a6e3a0",1553499926637,"# Java知识点\n\n\n##  集合、线程\n\n\n\n### **HashMap实现原理**\n\nHashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。\n```java\n//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。\ntransient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;\n```\n\n\n![](https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png)\n\n**简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。**\n\n[参考资料](https://www.cnblogs.com/chengxiao/p/6059914.html)\n\n\n\n\n### **什么是一致性Hash算法**\n\n原因：\n应用场景：redis缓存假设使用普通hash取模的方式。在增加节点或减少节点时，映射规则将被改变，当应用无法从缓存中获取数据，则会想后端数据库请求数据\n\n![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbhiae1AfNYAibdp7ib2wTZTrpz1ZyCTibgvW1H5TXzXDlQnuuNiaK0ce42zv6hz0L3rt2icZePaAmT4Ddw/640)\n\n- hash值是个整数非负，非负整数的值范围做成一个圆环`Hash环`（0——2^32-1）；\n- 对集群的节点的某个属性（比如节点名）求hash值，放在环上；\n- 对数据key求hash值，也放在环上，按顺时针方向找到离它最近的节点，放在它上面。\n\n`附` 如何避免Hash环的数据倾斜？\n\n引入`虚拟节点`，例如将每台服务器就算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点\n![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbhiae1AfNYAibdp7ib2wTZTrpnNGzjcWYy3ylL7s1Bq2UKicU5mYG8SHsuIFTOf2PMe2FstpM2gMeQbw/640)\n\n[参考文章](https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368)",[[1553499912439,["28447@DESKTOP-BE7HQ26",[[1,42,"，Concurreny"]],[42,42],[53,53]]],[1553499912814,["28447@DESKTOP-BE7HQ26",[[-1,52,"y"]],[53,53],[52,52]]],[1553499916550,["28447@DESKTOP-BE7HQ26",[[1,52,"tHashmao"]],[52,52],[60,60]]],[1553499918223,["28447@DESKTOP-BE7HQ26",[[-1,57,"mao"]],[60,60],[57,57]]],[1553499922484,["28447@DESKTOP-BE7HQ26",[[1,57,"Map实现远离哦"]],[57,57],[65,65]]],[1553499923263,["28447@DESKTOP-BE7HQ26",[[-1,62,"远离哦"]],[65,65],[62,62]]],[1553499924896,["28447@DESKTOP-BE7HQ26",[[1,62,"原理"]],[62,62],[64,64]]],[1553499937382,["28447@DESKTOP-BE7HQ26",[[1,35,"Hash"]],[31,31],[35,35]]],[1553499943101,["28447@DESKTOP-BE7HQ26",[[1,35,"Table实现远看i"]],[35,35],[45,45]]],[1553499944042,["28447@DESKTOP-BE7HQ26",[[-1,42,"远看i"]],[45,45],[42,42]]],[1553499946674,["28447@DESKTOP-BE7HQ26",[[1,42,"原理，"]],[42,42],[45,45]]],[1553499953661,["28447@DESKTOP-BE7HQ26",[[1,81,"HashMap:"]],[81,81],[89,89]]],[1553499958373,["28447@DESKTOP-BE7HQ26",[[1,81,"****"]],[81,81],[83,83]]],[1553499960712,["28447@DESKTOP-BE7HQ26",[[-1,85,"HashMap:"]],[85,93],[85,85]]],[1553499961373,["28447@DESKTOP-BE7HQ26",[[1,83,"HashMap:"]],[83,83],[91,91]]],[1553499964594,["28447@DESKTOP-BE7HQ26",[[1,81,"\n"]],[80,80],[81,81]]],[1553499964827,["28447@DESKTOP-BE7HQ26",[[1,82,"\n"]],[81,81],[82,82]]],[1553499978891,["28447@DESKTOP-BE7HQ26",[[1,82,"****"]],[82,82],[84,84]]],[1553499979817,["28447@DESKTOP-BE7HQ26",[[1,84,"HashTable"]],[84,84],[93,93]]],[1553499981310,["28447@DESKTOP-BE7HQ26",[[1,96,"\n"]],[95,95],[96,96]]],[1553499990666,["28447@DESKTOP-BE7HQ26",[[1,96,"*   底层数组+链表实现，无论key还是value都**不能为null**，线程**安全**，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化\n*   初始size为**11**，扩容：newsize = olesize*2+1\n*   计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length"]],[96,96],[300,300]]],[1553500002312,["28447@DESKTOP-BE7HQ26",[[1,302," \n*"]],[300,300],[303,303]]],[1553500004165,["28447@DESKTOP-BE7HQ26",[[-1,301,"* "]],[303,303],[301,301]]],[1553500007781,["28447@DESKTOP-BE7HQ26",[[-1,311,":"]],[312,312],[311,311]]],[1553500035796,["28447@DESKTOP-BE7HQ26",[[1,314,"\n"]],[313,313],[314,314]]],[1553500036004,["28447@DESKTOP-BE7HQ26",[[1,315,"\n"]],[314,314],[315,315]]],[1553500036866,["28447@DESKTOP-BE7HQ26",[[1,314,"*   底层数组+链表实现，可**以存储null键和null值**，线程**不安全**\n*   初始size为**16**，扩容：newsize = oldsize*2，size一定为2的n次幂\n*   扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入\n*   插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）\n*   当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀\n*   计算index方法：index = hash & (tab.length – 1)"]],[314,314],[606,606]]],[1553500276580,["28447@DESKTOP-BE7HQ26",[[1,822,"HashMap和Hashtable都是用hash算法来决定其元素的存储，因此HashMap和Hashtable的hash表包含如下属性：\n\n*   容量（capacity）：hash表中桶的数量\n*   初始化容量（initial capacity）：创建hash表时桶的数量，HashMap允许在构造器中指定初始化容量\n*   尺寸（size）：当前hash表中记录的数量\n*   负载因子（load factor）：负载因子等于“size/capacity”。负载因子为0，表示空的hash表，0.5表示半满的散列表，依此类推。轻负载的散列表具有冲突少、适宜插入与查询的特点（但是使用Iterator迭代元素时比较慢）\n\n除此之外，hash表里还有一个“负载极限”，“负载极限”是一个0～1的数值，“负载极限”决定了hash表的最大填满程度。当hash表中的负载因子达到指定的“负载极限”时，hash表会自动成倍地增加容量（桶的数量），并将原有的对象重新分配，放入新的桶内，这称为rehashing。"]],[822,822],[1274,1274]]],[1553500292151,["28447@DESKTOP-BE7HQ26",[[1,1276,"\n"]],[1274,1274],[1275,1275]]],[1553500292351,["28447@DESKTOP-BE7HQ26",[[1,1277,"\n"]],[1275,1275],[1276,1276]]],[1553500298687,["28447@DESKTOP-BE7HQ26",[[1,1276,"“负载极限”的默认值（0.75）是时间和空间成本上的一种折中：\n\n*   较高的“负载极限”可以降低hash表所占用的内存空间，但会增加查询数据的时间开销，而查询是最频繁的操作（HashMap的get()与put()方法都要用到查询）\n*   较低的“负载极限”会提高查询数据的性能，但会增加hash表所占用的内存开销"]],[1276,1276],[1435,1435]]],[1553500303015,["28447@DESKTOP-BE7HQ26",[[1,1276,"****"]],[1276,1276],[1278,1278]]],[1553500305056,["28447@DESKTOP-BE7HQ26",[[-1,1280,"“负载极限”的默认值（0.75）是时间和空间成本上的一种折中"]],[1280,1310],[1280,1280]]],[1553500308012,["28447@DESKTOP-BE7HQ26",[[1,1278,"“负载极限”的默认值（0.75）是时间和空间成本上的一种折中"]],[1278,1278],[1308,1308]]],[1553500311578,["28447@DESKTOP-BE7HQ26",[[-1,1310,"："]],[1311,1311],[1310,1310]]],[1553500318357,["28447@DESKTOP-BE7HQ26",[[1,1837,"****"]],[1837,1837],[1839,1839]]],[1553500323439,["28447@DESKTOP-BE7HQ26",[[1,1839,"### **ConcurrentHashMap**"]],[1839,1839],[1864,1864]]],[1553500328794,["28447@DESKTOP-BE7HQ26",[[-1,1839,"**### "]],[1839,1842],[1837,1837]]],[1553500329701,["28447@DESKTOP-BE7HQ26",[[-1,1858,"**"]],[1860,1860],[1858,1858]]],[1553500330602,["28447@DESKTOP-BE7HQ26",[[1,1861,"\n"]],[1858,1858],[1859,1859]]],[1553500330843,["28447@DESKTOP-BE7HQ26",[[1,1862,"\n"]],[1859,1859],[1860,1860]]],[1553500336029,["28447@DESKTOP-BE7HQ26",[[1,1863,"\n"]],[1858,1858],[1859,1859]]],[1553500573758,["28447@DESKTOP-BE7HQ26",[[1,1859,"*   底层采用分段的数组+链表实现，线程**安全**\n*   通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)\n*   Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术\n*   有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁\n*   扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容"]],[1859,1859],[2252,2252]]],[1553500666344,["28447@DESKTOP-BE7HQ26",[[-1,1537,"**简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。**"]],[1537,1777],[1537,1537]]],[1553500666916,["28447@DESKTOP-BE7HQ26",[[-1,1538,"\n"]],[1537,1537],[1536,1536]]],[1553500701366,["28447@DESKTOP-BE7HQ26",[[1,2014,"ConcurrentHashMap比HashMap多出了一个类Segment，而Segment是一个可重入锁。\n\nConcurrentHashMap是使用了锁分段技术来保证线程安全的。\n\n**锁分段技术**：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 \n\nConcurrentHashMap提供了与Hashtable和SynchronizedMap不同的锁机制。Hashtable中采用的锁机制是一次锁住整个hash表，从而在同一时刻只能由一个线程对其进行操作；而ConcurrentHashMap中则是一次锁住一个桶。\n\nConcurrentHashMap默认将hash表分为16个桶，诸如get、put、remove等常用操作只锁住当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。"]],[2014,2014],[2429,2429]]],[1553500791565,["28447@DESKTOP-BE7HQ26",[[-1,2183," "],[1,2184," "],[1,2239,"****"]],[2239,2239],[2241,2241]]],[1553500798673,["28447@DESKTOP-BE7HQ26",[[-1,2243,"Hashtable中采用的锁机制是一次锁住整个hash表"]],[2243,2271],[2243,2243]]],[1553500800991,["28447@DESKTOP-BE7HQ26",[[1,2241,"Hashtable中采用的锁机制是一次锁住整个hash表"]],[2241,2241],[2269,2269]]],[1553500807587,["28447@DESKTOP-BE7HQ26",[[1,2294,"****"]],[2294,2294],[2296,2296]]],[1553500810627,["28447@DESKTOP-BE7HQ26",[[-1,2298,"ConcurrentHashMap中则是一次锁住一个桶"]],[2298,2325],[2298,2298]]],[1553500811403,["28447@DESKTOP-BE7HQ26",[[1,2296,"ConcurrentHashMap中则是一次锁住一个桶"]],[2296,2296],[2323,2323]]],[1553501747207,["28447@DESKTOP-BE7HQ26",[[1,323,"da"]],[323,323],[325,325]]],[1553501747909,["28447@DESKTOP-BE7HQ26",[[-1,323,"da"]],[325,325],[323,323]]],[1553501749326,["28447@DESKTOP-BE7HQ26",[[1,323,"单项"]],[323,323],[325,325]]],[1553501750085,["28447@DESKTOP-BE7HQ26",[[-1,323,"单项"]],[325,325],[323,323]]],[1553501751754,["28447@DESKTOP-BE7HQ26",[[1,323,"单向"]],[323,323],[325,325]]],[1553501755521,["28447@DESKTOP-BE7HQ26",[[1,105,"单向"]],[105,105],[107,107]]],[1553501766482,["28447@DESKTOP-BE7HQ26",[[1,1636,"单向"]],[1636,1636],[1638,1638]]],[1553501917568,["28447@DESKTOP-BE7HQ26",[[1,81,"****"]],[81,81],[83,83]]],[1553501920522,["28447@DESKTOP-BE7HQ26",[[1,83,"一下未"]],[83,83],[86,86]]],[1553501921353,["28447@DESKTOP-BE7HQ26",[[-1,85,"未"]],[86,86],[85,85]]],[1553501922534,["28447@DESKTOP-BE7HQ26",[[1,85,"为"]],[85,85],[86,86]]],[1553501923968,["28447@DESKTOP-BE7HQ26",[[-1,83,"一下"]],[85,85],[83,83]]],[1553501925769,["28447@DESKTOP-BE7HQ26",[[1,83,"以下"]],[83,83],[85,85]]],[1553501931811,["28447@DESKTOP-BE7HQ26",[[1,86,"jdk1.7实现方式"]],[86,86],[96,96]]],[1553501935192,["28447@DESKTOP-BE7HQ26",[[1,99,"\n"]],[98,98],[99,99]]],[1553501936312,["28447@DESKTOP-BE7HQ26",[[1,99,"****"]],[99,99],[101,101]]],[1553501942394,["28447@DESKTOP-BE7HQ26",[[1,101,"jdk1.8shi"]],[101,101],[110,110]]],[1553501943082,["28447@DESKTOP-BE7HQ26",[[-1,107,"shi"]],[110,110],[107,107]]],[1553501947804,["28447@DESKTOP-BE7HQ26",[[1,107,"实现方式不同："]],[107,107],[114,114]]],[1553501949840,["28447@DESKTOP-BE7HQ26",[[-1,81,"**以下为jdk1.7实现方式**"]],[81,98],[81,81]]],[1553501951107,["28447@DESKTOP-BE7HQ26",[[1,100,"\n"]],[99,99],[100,100]]],[1553501951418,["28447@DESKTOP-BE7HQ26",[[1,100,"**以下为jdk1.7实现方式**"]],[100,100],[117,117]]],[1553501958962,["28447@DESKTOP-BE7HQ26",[[1,94,"与jdk1.7"]],[94,94],[101,101]]],[1553501961321,["28447@DESKTOP-BE7HQ26",[[1,107,"\n"]],[106,106],[107,107]]],[1553501961495,["28447@DESKTOP-BE7HQ26",[[1,108,"\n"]],[107,107],[108,108]]],[1553501970129,["28447@DESKTOP-BE7HQ26",[[1,107,"HashMaphe"]],[107,107],[116,116]]],[1553501970640,["28447@DESKTOP-BE7HQ26",[[-1,114,"he"]],[116,116],[114,114]]],[1553501977806,["28447@DESKTOP-BE7HQ26",[[1,114,"和ConcurrentHashMapdo"]],[114,114],[134,134]]],[1553501978751,["28447@DESKTOP-BE7HQ26",[[-1,132,"do"]],[134,134],[132,132]]],[1553501984882,["28447@DESKTOP-BE7HQ26",[[1,132,"都加入了红黑树"]],[132,132],[139,139]]],[1553501987332,["28447@DESKTOP-BE7HQ26",[[1,136,"****"]],[136,136],[138,138]]],[1553501989723,["28447@DESKTOP-BE7HQ26",[[-1,140,"红黑树"]],[140,143],[140,140]]],[1553501990373,["28447@DESKTOP-BE7HQ26",[[1,138,"红黑树"]],[138,138],[141,141]]],[1553501991490,["28447@DESKTOP-BE7HQ26",[[1,143,"，"]],[143,143],[144,144]]],[1553501992544,["28447@DESKTOP-BE7HQ26",[[1,144,"放"]],[144,144],[145,145]]],[1553501992854,["28447@DESKTOP-BE7HQ26",[[-1,144,"放"]],[145,145],[144,144]]],[1553501993935,["28447@DESKTOP-BE7HQ26",[[1,144,"打包发到"]],[144,144],[148,148]]],[1553501995071,["28447@DESKTOP-BE7HQ26",[[-1,144,"打包发到"]],[148,148],[144,144]]],[1553501995974,["28447@DESKTOP-BE7HQ26",[[1,144,"当"]],[144,144],[145,145]]],[1553501999139,["28447@DESKTOP-BE7HQ26",[[-1,144,"当"]],[145,145],[144,144]]],[1553502044417,["28447@DESKTOP-BE7HQ26",[[1,144,"对于个数超过8个（）"]],[144,144],[154,154]]],[1553502047715,["28447@DESKTOP-BE7HQ26",[[1,153,"默认值"]],[153,153],[156,156]]],[1553502049593,["28447@DESKTOP-BE7HQ26",[[1,157,"的"]],[157,157],[158,158]]],[1553502062575,["28447@DESKTOP-BE7HQ26",[[1,158,"列表，jdk1.8曹勇"]],[158,158],[169,169]]],[1553502063272,["28447@DESKTOP-BE7HQ26",[[-1,167,"曹勇"]],[169,169],[167,167]]],[1553502067146,["28447@DESKTOP-BE7HQ26",[[1,167,"采用红褐黑素"]],[167,167],[173,173]]],[1553502068393,["28447@DESKTOP-BE7HQ26",[[-1,169,"红褐黑素"]],[173,173],[169,169]]],[1553502084971,["28447@DESKTOP-BE7HQ26",[[1,169,"红黑树的结构，查询的时间复杂度可以讲到"]],[169,169],[188,188]]],[1553502085829,["28447@DESKTOP-BE7HQ26",[[-1,186,"讲到"]],[188,188],[186,186]]],[1553502090987,["28447@DESKTOP-BE7HQ26",[[1,186,"降到O（）"]],[186,186],[191,191]]],[1553502094930,["28447@DESKTOP-BE7HQ26",[[1,190,"logN"]],[190,190],[194,194]]],[1553502097374,["28447@DESKTOP-BE7HQ26",[[-1,189,"（l"]],[191,191],[189,189]]],[1553502098267,["28447@DESKTOP-BE7HQ26",[[1,189,"（"]],[189,189],[190,190]]],[1553502099267,["28447@DESKTOP-BE7HQ26",[[-1,189,"（"]],[190,190],[189,189]]],[1553502101061,["28447@DESKTOP-BE7HQ26",[[1,189,"(l"]],[189,189],[191,191]]],[1553502102641,["28447@DESKTOP-BE7HQ26",[[-1,194,"）"]],[195,195],[194,194]]],[1553502103155,["28447@DESKTOP-BE7HQ26",[[1,194,")"]],[194,194],[195,195]]],[1553502104342,["28447@DESKTOP-BE7HQ26",[[1,197,"\n"]],[195,195],[196,196]]],[1553502112161,["28447@DESKTOP-BE7HQ26",[[1,107,"-"]],[107,107],[108,108]]],[1553502112378,["28447@DESKTOP-BE7HQ26",[[1,108," "]],[108,108],[109,109]]],[1553502128511,["28447@DESKTOP-BE7HQ26",[[1,198,"- ConcurrentHashMap：**取消segments字段，直接采用transient volatile HashEntry<K,V>[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率**"]],[198,198],[328,328]]],[1553502133535,["28447@DESKTOP-BE7HQ26",[[-1,324,"概率**"]],[328,328],[324,324]]],[1553502134835,["28447@DESKTOP-BE7HQ26",[[1,324,"概率**"]],[324,324],[328,328]]],[1553502136643,["28447@DESKTOP-BE7HQ26",[[-1,326,"**"]],[328,328],[326,326]]],[1553502138390,["28447@DESKTOP-BE7HQ26",[[-1,218,"**"]],[220,220],[218,218]]],[1553502316513,["28447@DESKTOP-BE7HQ26",[[1,1862,"\n"]],[1860,1860],[1861,1861]]],[1553502317948,["28447@DESKTOP-BE7HQ26",[[1,1861,"[]"]],[1861,1861],[1863,1863]]],[1553502320501,["28447@DESKTOP-BE7HQ26",[[1,1862,"参考"]],[1862,1862],[1864,1864]]],[1553502323618,["28447@DESKTOP-BE7HQ26",[[-1,1862,"参考"]],[1864,1864],[1862,1862]]],[1553502333593,["28447@DESKTOP-BE7HQ26",[[1,1862,"jdk.7,1.8"]],[1862,1862],[1871,1871]]],[1553502335284,["28447@DESKTOP-BE7HQ26",[[-1,1865,"."]],[1866,1866],[1865,1865]]],[1553502336416,["28447@DESKTOP-BE7HQ26",[[1,1865,"1."]],[1865,1865],[1867,1867]]],[1553502340561,["28447@DESKTOP-BE7HQ26",[[1,1872,"中"]],[1872,1872],[1873,1873]]],[1553502355645,["28447@DESKTOP-BE7HQ26",[[-1,1862,"jdk1.7,1.8中"],[1,1873,"# Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析"]],[1862,1873],[1906,1906]]],[1553502360216,["28447@DESKTOP-BE7HQ26",[[1,1907,"("]],[1907,1907],[1908,1908]]],[1553502360250,["28447@DESKTOP-BE7HQ26",[[1,1908,"https://)"]],[1908,1908],[1908,1916]]],[1553502364297,["28447@DESKTOP-BE7HQ26",[[-1,1910,"t"]],[1911,1911],[1910,1910]]],[1553502367747,["28447@DESKTOP-BE7HQ26",[[-1,1908,"htps://"]],[1915,1915],[1908,1908]]],[1553502368065,["28447@DESKTOP-BE7HQ26",[[1,1908,"http://www.importnew.com/28263.html"]],[1908,1908],[1943,1943]]],[1553502371616,["28447@DESKTOP-BE7HQ26",[[1,1946,"\n"]],[1944,1944],[1945,1945]]],[1553502387321,["28447@DESKTOP-BE7HQ26",[[1,1945,"[]("]],[1945,1945],[1948,1948]]],[1553502387354,["28447@DESKTOP-BE7HQ26",[[1,1948,"https://)"]],[1948,1948],[1948,1956]]],[1553502388128,["28447@DESKTOP-BE7HQ26",[[1,1956,"www.cnblogs.com/everSeeker/p/5601861.html"]],[1948,1956],[1997,1997]]],[1553502402527,["28447@DESKTOP-BE7HQ26",[[1,1946,"# [ConcurrentHashMap在jdk1.8中的改进](https://www.cnblogs.com/everSeeker/p/5601861.html)"]],[1946,1946],[2029,2029]]],[1553502413181,["28447@DESKTOP-BE7HQ26",[[-1,1978,"(https://www.cnblogs.com/everSeeker/p/5601861.html)]"]],[1978,2029],[1977,1977]]],[1553502417510,["28447@DESKTOP-BE7HQ26",[[-1,1948,"["]],[1949,1949],[1948,1948]]],[1553502420501,["28447@DESKTOP-BE7HQ26",[[-1,1946,"#"]],[1947,1947],[1946,1946]]],[1553502422400,["28447@DESKTOP-BE7HQ26",[[-1,1862,"#"]],[1863,1863],[1862,1862]]],[1553502457351,["28447@DESKTOP-BE7HQ26",[[-1,1805,"参考资料"],[1,1809,"j"]],[1805,1809],[1806,1806]]],[1553502465068,["28447@DESKTOP-BE7HQ26",[[1,1806,"dk1.7代码hash"]],[1806,1806],[1817,1817]]],[1553502466085,["28447@DESKTOP-BE7HQ26",[[-1,1813,"hash"]],[1817,1817],[1813,1813]]],[1553502469498,["28447@DESKTOP-BE7HQ26",[[1,1813,"HashMao"]],[1813,1813],[1820,1820]]],[1553502470156,["28447@DESKTOP-BE7HQ26",[[-1,1819,"o"]],[1820,1820],[1819,1819]]],[1553502473678,["28447@DESKTOP-BE7HQ26",[[1,1819,"p原理"]],[1819,1819],[1822,1822]]],[1553502476292,["28447@DESKTOP-BE7HQ26",[[-1,1811,"代码"]],[1813,1813],[1811,1811]]],[1553502476723,["28447@DESKTOP-BE7HQ26",[[1,1811," "]],[1811,1811],[1812,1812]]],[1553502480558,["28447@DESKTOP-BE7HQ26",[[-1,1804,"[jdk1.7 HashMap原理](https://www.cnblogs.com/chengxiao/p/6059914.html)\n[ Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析](http://www.importnew.com/28263.html)\n[ ConcurrentHashMap在jdk1.8中的改进](https://www.cnblogs.com/everSeeker/p/5601861.html)\n"]],[1804,2039],[1804,1804]]],[1553502481941,["28447@DESKTOP-BE7HQ26",[[-1,1804,"\n"]],[1804,1804],[1803,1803]]],[1553502484995,["28447@DESKTOP-BE7HQ26",[[1,82,"\n"]],[81,81],[82,82]]],[1553502485867,["28447@DESKTOP-BE7HQ26",[[1,81,"[jdk1.7 HashMap原理](https://www.cnblogs.com/chengxiao/p/6059914.html)\n[ Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析](http://www.importnew.com/28263.html)\n[ ConcurrentHashMap在jdk1.8中的改进](https://www.cnblogs.com/everSeeker/p/5601861.html)\n"]],[81,81],[316,316]]],[1553502513808,["28447@DESKTOP-BE7HQ26",[[1,2885,"\n"]],[2883,2883],[2884,2884]]],[1553502513978,["28447@DESKTOP-BE7HQ26",[[1,2886,"\n"]],[2884,2884],[2885,2885]]],[1553502514872,["28447@DESKTOP-BE7HQ26",[[1,2887,"\n"]],[2884,2884],[2885,2885]]],[1553502515066,["28447@DESKTOP-BE7HQ26",[[1,2888,"\n"]],[2885,2885],[2886,2886]]],[1553502522722,["28447@DESKTOP-BE7HQ26",[[1,2886,"### ****"]],[2886,2886],[2892,2892]]],[1553502537649,["28447@DESKTOP-BE7HQ26",[[1,2892,"红黑树，为什么允许局部不平衡"]],[2892,2892],[2906,2906]]],[1553502538579,["28447@DESKTOP-BE7HQ26",[[1,2911,"\n"]],[2908,2908],[2909,2909]]],[1553502677239,["28447@DESKTOP-BE7HQ26",[[1,82,"1、"]],[82,82],[84,84]]],[1553502680223,["28447@DESKTOP-BE7HQ26",[[1,154,"2、"]],[154,154],[156,156]]],[1553502682219,["28447@DESKTOP-BE7HQ26",[[1,239,"3、"]],[239,239],[241,241]]],[1553502726165,["28447@DESKTOP-BE7HQ26",[[1,322,"![2](https://javadoop.com/blogimages/map/2.png)"]],[322,322],[369,369]]],[1553502729355,["28447@DESKTOP-BE7HQ26",[[1,322,"\n"]],[321,321],[322,322]]],[1553502729734,["28447@DESKTOP-BE7HQ26",[[1,323,"\n"]],[322,322],[323,323]]],[1553502733070,["28447@DESKTOP-BE7HQ26",[[1,323,"****"]],[323,323],[325,325]]],[1553502744723,["28447@DESKTOP-BE7HQ26",[[1,325,"jdk1.8 HashMap节后"]],[325,325],[341,341]]],[1553502745424,["28447@DESKTOP-BE7HQ26",[[-1,339,"节后"]],[341,341],[339,339]]],[1553502746885,["28447@DESKTOP-BE7HQ26",[[1,339,"结构"]],[339,339],[341,341]]],[1553502751258,["28447@DESKTOP-BE7HQ26",[[1,341,"图"]],[341,341],[342,342]]],[1553502753825,["28447@DESKTOP-BE7HQ26",[[1,342,"："]],[342,342],[343,343]]],[1553502754757,["28447@DESKTOP-BE7HQ26",[[1,346,"\n"]],[345,345],[346,346]]],[1553502756891,["28447@DESKTOP-BE7HQ26",[[-1,346,"\n"]],[346,346],[345,345]]],[1553504008986,["28447@DESKTOP-BE7HQ26",[[1,2989,"\n"]],[2987,2987],[2988,2988]]],[1553504009199,["28447@DESKTOP-BE7HQ26",[[1,2990,"\n"]],[2988,2988],[2989,2989]]],[1553513802535,["28447@DESKTOP-BE7HQ26",[[1,2963,"\n"]],[2962,2962],[2963,2963]]],[1553513802704,["28447@DESKTOP-BE7HQ26",[[1,2964,"\n"]],[2963,2963],[2964,2964]]],[1553513807528,["28447@DESKTOP-BE7HQ26",[[1,2963,"### ****"]],[2963,2963],[2969,2969]]],[1553513809294,["28447@DESKTOP-BE7HQ26",[[1,2969,"hash"]],[2969,2969],[2973,2973]]],[1553513810219,["28447@DESKTOP-BE7HQ26",[[-1,2969,"hash"]],[2973,2973],[2969,2969]]],[1553513813738,["28447@DESKTOP-BE7HQ26",[[1,2969,"Hashmap"]],[2969,2969],[2976,2976]]],[1553513814651,["28447@DESKTOP-BE7HQ26",[[-1,2973,"map"]],[2976,2976],[2973,2973]]],[1553513817399,["28447@DESKTOP-BE7HQ26",[[1,2973,"Mapz"]],[2973,2973],[2977,2977]]],[1553513817845,["28447@DESKTOP-BE7HQ26",[[-1,2976,"z"]],[2977,2977],[2976,2976]]],[1553513836298,["28447@DESKTOP-BE7HQ26",[[1,2976,"在高并发环境写"]],[2976,2976],[2983,2983]]],[1553513837808,["28447@DESKTOP-BE7HQ26",[[-1,2982,"写"]],[2983,2983],[2982,2982]]],[1553513847639,["28447@DESKTOP-BE7HQ26",[[1,2982,"下会产生的问题："]],[2982,2982],[2990,2990]]],[1553513861751,["28447@DESKTOP-BE7HQ26",[[-1,2989,"："]],[2990,2990],[2989,2989]]],[1553513863476,["28447@DESKTOP-BE7HQ26",[[1,2993,"\n"]],[2991,2991],[2992,2992]]],[1553513865749,["28447@DESKTOP-BE7HQ26",[[1,2992,"问题;"]],[2992,2992],[2995,2995]]],[1553513866817,["28447@DESKTOP-BE7HQ26",[[-1,2994,";"]],[2995,2995],[2994,2994]]],[1553513867968,["28447@DESKTOP-BE7HQ26",[[1,2994,"：1"]],[2994,2994],[2996,2996]]],[1553513868550,["28447@DESKTOP-BE7HQ26",[[-1,2995,"1"]],[2996,2996],[2995,2995]]],[1553513869468,["28447@DESKTOP-BE7HQ26",[[1,2995,"``"]],[2995,2995],[2997,2997]]],[1553513870041,["28447@DESKTOP-BE7HQ26",[[-1,2995,"``"]],[2997,2997],[2995,2995]]],[1553513872573,["28447@DESKTOP-BE7HQ26",[[1,2995,"- wasjd "]],[2995,2995],[3003,3003]]],[1553513874411,["28447@DESKTOP-BE7HQ26",[[-1,2996," wasjd "]],[3003,3003],[2996,2996]]],[1553513874746,["28447@DESKTOP-BE7HQ26",[[1,2998,"\n"]],[2996,2996],[2997,2997]]],[1553513875764,["28447@DESKTOP-BE7HQ26",[[-1,2998,"\n"]],[2997,2997],[2996,2996]]],[1553513876012,["28447@DESKTOP-BE7HQ26",[[1,2998,"\n"]],[2996,2996],[2997,2997]]],[1553513876487,["28447@DESKTOP-BE7HQ26",[[-1,2998,"\n"]],[2997,2997],[2996,2996]]],[1553513876710,["28447@DESKTOP-BE7HQ26",[[-1,2995,"-"]],[2996,2996],[2995,2995]]],[1553513877428,["28447@DESKTOP-BE7HQ26",[[1,2997,"\n"]],[2995,2995],[2996,2996]]],[1553513877667,["28447@DESKTOP-BE7HQ26",[[1,2996,"-"]],[2996,2996],[2997,2997]]],[1553513878518,["28447@DESKTOP-BE7HQ26",[[1,2992,"### "],[-1,2995,"\n-"]],[2997,2997],[3001,3001]]],[1553513879789,["28447@DESKTOP-BE7HQ26",[[-1,3000,"\n"]],[3001,3001],[3000,3000]]],[1553513880749,["28447@DESKTOP-BE7HQ26",[[1,3000,"\n"]],[3000,3000],[3001,3001]]],[1553513885202,["28447@DESKTOP-BE7HQ26",[[-1,2992,"###"]],[2995,2995],[2992,2992]]],[1553513887194,["28447@DESKTOP-BE7HQ26",[[1,2997," \n"]],[2996,2996],[2998,2998]]],[1553513904432,["28447@DESKTOP-BE7HQ26",[[1,2998,"- HashMap死循环，照成CPU100%负载"]],[2998,2998],[3022,3022]]],[1553513904990,["28447@DESKTOP-BE7HQ26",[[1,3023," - \n"]],[3022,3022],[3026,3026]]],[1553513909340,["28447@DESKTOP-BE7HQ26",[[1,3026,"触发"]],[3026,3026],[3028,3028]]],[1553513913113,["28447@DESKTOP-BE7HQ26",[[1,3028,"fail-fs"]],[3028,3028],[3035,3035]]],[1553513913764,["28447@DESKTOP-BE7HQ26",[[-1,3034,"s"]],[3035,3035],[3034,3034]]],[1553513914240,["28447@DESKTOP-BE7HQ26",[[1,3034,"ast"]],[3034,3034],[3037,3037]]],[1553513930906,["28447@DESKTOP-BE7HQ26",[[1,3038," - \n"]],[3037,3037],[3041,3041]]],[1553513931126,["28447@DESKTOP-BE7HQ26",[[-1,3038," - "]],[3041,3041],[3039,3039]]],[1553513933357,["28447@DESKTOP-BE7HQ26",[[1,3039,"****"]],[3039,3039],[3041,3041]]],[1553513941983,["28447@DESKTOP-BE7HQ26",[[1,3041,"HashMap死循环的原因"]],[3041,3041],[3054,3054]]],[1553513943314,["28447@DESKTOP-BE7HQ26",[[1,3057,"\n"]],[3056,3056],[3057,3057]]],[1553513982190,["28447@DESKTOP-BE7HQ26",[[1,3058,"\n"]],[3057,3057],[3058,3058]]],[1553513982690,["28447@DESKTOP-BE7HQ26",[[1,3059,"\n"]],[3058,3058],[3059,3059]]],[1553513982737,["28447@DESKTOP-BE7HQ26",[[1,3060,"\n"]],[3059,3059],[3060,3060]]],[1553513982768,["28447@DESKTOP-BE7HQ26",[[1,3061,"\n"]],[3060,3060],[3061,3061]]],[1553513982801,["28447@DESKTOP-BE7HQ26",[[1,3062,"\n"]],[3061,3061],[3062,3062]]],[1553513982856,["28447@DESKTOP-BE7HQ26",[[1,3063,"\n"]],[3062,3062],[3063,3063]]],[1553513982885,["28447@DESKTOP-BE7HQ26",[[1,3064,"\n"]],[3063,3063],[3064,3064]]],[1553513982918,["28447@DESKTOP-BE7HQ26",[[1,3065,"\n"]],[3064,3064],[3065,3065]]],[1553513982978,["28447@DESKTOP-BE7HQ26",[[1,3066,"\n"]],[3065,3065],[3066,3066]]],[1553514019471,["28447@DESKTOP-BE7HQ26",[[1,3057,"void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } Entry[] newTable = new Entry[newCapacity]; // transfer方法是真正执行rehash的操作，容易在高并发时发生问题 transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); }"]],[3057,3057],[3396,3396]]],[1553514020901,["28447@DESKTOP-BE7HQ26",[[-1,3057,"void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } Entry[] newTable = new Entry[newCapacity]; // transfer方法是真正执行rehash的操作，容易在高并发时发生问题 transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); }"]],[3396,3396],[3057,3057]]],[1553514022439,["28447@DESKTOP-BE7HQ26",[[1,3057,"··"]],[3057,3057],[3059,3059]]],[1553514023048,["28447@DESKTOP-BE7HQ26",[[-1,3057,"··"]],[3059,3059],[3057,3057]]],[1553514023836,["28447@DESKTOP-BE7HQ26",[[1,3057,"```"]],[3057,3057],[3060,3060]]],[1553514023885,["28447@DESKTOP-BE7HQ26",[[1,3060,"language\n```\n"]],[3060,3060],[3060,3068]]],[1553514024723,["28447@DESKTOP-BE7HQ26",[[-1,3060,"language"],[1,3068,"j"]],[3060,3068],[3061,3061]]],[1553514025346,["28447@DESKTOP-BE7HQ26",[[1,3061,"ava"]],[3061,3061],[3064,3064]]],[1553514025653,["28447@DESKTOP-BE7HQ26",[[1,3065,"\n"]],[3064,3064],[3065,3065]]],[1553514026247,["28447@DESKTOP-BE7HQ26",[[1,3065,"void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } Entry[] newTable = new Entry[newCapacity]; // transfer方法是真正执行rehash的操作，容易在高并发时发生问题 transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); }"]],[3065,3065],[3404,3404]]],[1553514032124,["28447@DESKTOP-BE7HQ26",[[1,3096,"\n"]],[3096,3096],[3097,3097]]],[1553514038471,["28447@DESKTOP-BE7HQ26",[[1,3158,"\n"]],[3158,3158],[3159,3159]]],[1553514042094,["28447@DESKTOP-BE7HQ26",[[1,3198,"\n"]],[3198,3198],[3199,3199]]],[1553514044850,["28447@DESKTOP-BE7HQ26",[[1,3230,"\n"]],[3230,3230],[3231,3231]]],[1553514048352,["28447@DESKTOP-BE7HQ26",[[1,3239,"\n"]],[3239,3239],[3240,3240]]],[1553514051524,["28447@DESKTOP-BE7HQ26",[[1,3242,"\n"]],[3242,3242],[3243,3243]]],[1553514056012,["28447@DESKTOP-BE7HQ26",[[1,3286,"\n"]],[3286,3286],[3287,3287]]],[1553514059195,["28447@DESKTOP-BE7HQ26",[[1,3327,"\n"]],[3327,3327],[3328,3328]]],[1553514062707,["28447@DESKTOP-BE7HQ26",[[1,3348,"\n"]],[3348,3348],[3349,3349]]],[1553514065117,["28447@DESKTOP-BE7HQ26",[[1,3367,"\n"]],[3367,3367],[3368,3368]]],[1553514068003,["28447@DESKTOP-BE7HQ26",[[1,3413,"\n"]],[3413,3413],[3414,3414]]],[1553514072557,["28447@DESKTOP-BE7HQ26",[[1,3097,"  "]],[3097,3097],[3099,3099]]],[1553514073412,["28447@DESKTOP-BE7HQ26",[[1,3143,"  "]],[3143,3143],[3145,3145]]],[1553514079003,["28447@DESKTOP-BE7HQ26",[[1,3125,"\n  "]],[3125,3125],[3128,3128]]],[1553514081945,["28447@DESKTOP-BE7HQ26",[[-1,3147," "]],[3148,3148],[3147,3147]]],[1553514083615,["28447@DESKTOP-BE7HQ26",[[1,3165,"  "]],[3165,3165],[3167,3167]]],[1553514085893,["28447@DESKTOP-BE7HQ26",[[1,3207,"      "]],[3207,3207],[3213,3213]]],[1553514087963,["28447@DESKTOP-BE7HQ26",[[1,3245,"      "]],[3245,3245],[3251,3251]]],[1553514089330,["28447@DESKTOP-BE7HQ26",[[1,3260,"    "]],[3260,3260],[3264,3264]]],[1553514090767,["28447@DESKTOP-BE7HQ26",[[-1,3263," "]],[3264,3264],[3263,3263]]],[1553514093176,["28447@DESKTOP-BE7HQ26",[[1,3266,"  "]],[3266,3266],[3268,3268]]],[1553514093917,["28447@DESKTOP-BE7HQ26",[[1,3312,"  "]],[3312,3312],[3314,3314]]],[1553514095870,["28447@DESKTOP-BE7HQ26",[[1,3355,"  "]],[3355,3355],[3357,3357]]],[1553514096598,["28447@DESKTOP-BE7HQ26",[[1,3378,"  "]],[3378,3378],[3380,3380]]],[1553514097506,["28447@DESKTOP-BE7HQ26",[[1,3399,"  "]],[3399,3399],[3401,3401]]],[1553514102872,["28447@DESKTOP-BE7HQ26",[[1,3057,"\n"]],[3056,3056],[3057,3057]]],[1553514110241,["28447@DESKTOP-BE7HQ26",[[1,3057,"HashMap进行存储时，如果size超过（当前最大容量*负载因子）时候会发生resize，首先看一下resize源代码："]],[3057,3057],[3118,3118]]],[1553514113549,["28447@DESKTOP-BE7HQ26",[[1,3057,"\n"]],[3056,3056],[3057,3057]]],[1553514452118,["28447@DESKTOP-BE7HQ26",[[1,3516,"而这段代码中又调用了transfer()方法，而这个方法实现的机制就是将每个链表转化到新链表，并且链表中的位置发生反转，而这在多线程情况下是很容易造成链表回路，从而发生死循环，我们看一下他的源代码:"]],[3516,3516],[3615,3615]]],[1553514453682,["28447@DESKTOP-BE7HQ26",[[1,3625,"\n"]],[3615,3615],[3616,3616]]],[1553514455001,["28447@DESKTOP-BE7HQ26",[[1,3616,"```"]],[3616,3616],[3619,3619]]],[1553514455048,["28447@DESKTOP-BE7HQ26",[[1,3619,"language\n```\n"]],[3619,3619],[3619,3627]]],[1553514456262,["28447@DESKTOP-BE7HQ26",[[-1,3619,"language"],[1,3627,"j"]],[3619,3627],[3620,3620]]],[1553514456664,["28447@DESKTOP-BE7HQ26",[[1,3620,"ava"]],[3620,3620],[3623,3623]]],[1553514457114,["28447@DESKTOP-BE7HQ26",[[1,3624,"\n"]],[3623,3623],[3624,3624]]],[1553514471263,["28447@DESKTOP-BE7HQ26",[[1,3624,"\t\tvoid transfer(Entry[] newTable) {\n\t        Entry[] src = table;\n\t        int newCapacity = newTable.length;\n\t        for (int j = 0; j < src.length; j++) {\n\t            Entry<K,V> e = src[j];\n\t            if (e != null) {\n\t                src[j] = null;\n\t                do {\n\t                    Entry<K,V> next = e.next;\n\t                    int i = indexFor(e.hash, newCapacity);\n\t                    e.next = newTable[i];\n\t                    newTable[i] = e;\n\t                    e = next;\n\t                } while (e != null);\n\t            }\n\t        }\n\t    }"]],[3624,3624],[4191,4191]]],[1553514537048,["28447@DESKTOP-BE7HQ26",[[-1,3624,"\t\t"],[-1,3632,"r"],[-1,3664,"     "],[-1,3694,"     "],[-1,3738,"     "],[-1,3783,"   "],[-1,3793,"  "],[-1,3826,"     "],[-1,3849,"   "],[-1,3863,"  "],[-1,3892,"     "],[-1,3903,"   "],[-1,3921,"  "],[-1,3950,"     "],[-1,4010,"    "],[-1,4029," "],[-1,4068,"     "],[-1,4091,"    "],[-1,4110," "],[-1,4122,"     "],[-1,4167,"     "],[-1,4175,"     "],[-1,4186,"    "]],[3624,4191],[4109,4109]]],[1553514563123,["28447@DESKTOP-BE7HQ26",[[1,3516,"\n"]],[3516,3516],[3517,3517]]],[1553514565586,["28447@DESKTOP-BE7HQ26",[[1,3516,"****"]],[3516,3516],[3518,3518]]],[1553514572733,["28447@DESKTOP-BE7HQ26",[[-1,3521,"而这段代码中又调用了transfer()方法，而这个方法实现的机制就是将每个链表转化到新链表，并且链表中的位置发生反转，而这在多线程情况下是很容易造成链表回路，从而发生死循环"]],[3521,3608],[3521,3521]]],[1553514573762,["28447@DESKTOP-BE7HQ26",[[1,3518,"而这段代码中又调用了transfer()方法，而这个方法实现的机制就是将每个链表转化到新链表，并且链表中的位置发生反转，而这在多线程情况下是很容易造成链表回路，从而发生死循环"]],[3518,3518],[3605,3605]]],[1553514575619,["28447@DESKTOP-BE7HQ26",[[-1,3607,"\n"]],[3608,3608],[3607,3607]]],[1553514619143,["28447@DESKTOP-BE7HQ26",[[-1,3039,"**HashMap死循环的原因**"]],[3039,3056],[3039,3039]]],[1553514620787,["28447@DESKTOP-BE7HQ26",[[1,3039,"**HashMap死循环的原因**"]],[3039,3039],[3039,3056]]],[1553514623813,["28447@DESKTOP-BE7HQ26",[[1,3041,"1\\"]],[3041,3041],[3043,3043]]],[1553514624942,["28447@DESKTOP-BE7HQ26",[[-1,3042,"\\"]],[3043,3043],[3042,3042]]],[1553514625174,["28447@DESKTOP-BE7HQ26",[[1,3042,"、"]],[3042,3042],[3043,3043]]],[1553514629116,["28447@DESKTOP-BE7HQ26",[[1,4120,"****HashMap死循环的原因****"]],[4120,4120],[4139,4139]]],[1553514632521,["28447@DESKTOP-BE7HQ26",[[-1,4123,"***HashMap死循环的原因**"]],[4139,4139],[4121,4121]]],[1553514634167,["28447@DESKTOP-BE7HQ26",[[1,4123,"***"]],[4121,4121],[4122,4122]]],[1553514635952,["28447@DESKTOP-BE7HQ26",[[-1,4124,"**"]],[4123,4123],[4121,4121]]],[1553514640751,["28447@DESKTOP-BE7HQ26",[[1,4122,"### 触发fail-fast"]],[4122,4122],[4137,4137]]],[1553514648980,["28447@DESKTOP-BE7HQ26",[[-1,4121,"*### "]],[4122,4125],[4121,4121]]],[1553514650035,["28447@DESKTOP-BE7HQ26",[[1,4121,"*"]],[4121,4121],[4122,4122]]],[1553514653744,["28447@DESKTOP-BE7HQ26",[[1,4122,"2\\"]],[4122,4122],[4124,4124]]],[1553514654846,["28447@DESKTOP-BE7HQ26",[[-1,4123,"\\"]],[4124,4124],[4123,4123]]],[1553514655163,["28447@DESKTOP-BE7HQ26",[[1,4123,"、"]],[4123,4123],[4124,4124]]],[1553514656686,["28447@DESKTOP-BE7HQ26",[[1,4147,"\n"]],[4137,4137],[4138,4138]]],[1553514656866,["28447@DESKTOP-BE7HQ26",[[1,4148,"\n"]],[4138,4138],[4139,4139]]],[1553514664380,["28447@DESKTOP-BE7HQ26",[[1,4138,"一个线程利用迭代器迭代时，另一个线程做插入删除操作，造成迭代的fast-fail。****"]],[4138,4138],[4181,4181]]],[1553514664927,["28447@DESKTOP-BE7HQ26",[[1,4181,"一个线程利用迭代器迭代时，另一个线程做插入删除操作，造成迭代的fast-fail。"]],[4181,4181],[4222,4222]]],[1553514668194,["28447@DESKTOP-BE7HQ26",[[-1,4138,"一个线程利用迭代器迭代时，另一个线程做插入删除操作，造成迭代的fast-fail。"]],[4138,4178],[4138,4138]]],[1553514671871,["28447@DESKTOP-BE7HQ26",[[1,4135,"："]],[4135,4135],[4136,4136]]],[1553514674973,["28447@DESKTOP-BE7HQ26",[[1,4195,"\n"]],[4184,4184],[4185,4185]]],[1553514675184,["28447@DESKTOP-BE7HQ26",[[1,4196,"\n"]],[4185,4185],[4186,4186]]],[1553514704463,["28447@DESKTOP-BE7HQ26",[[1,4185,"```"]],[4185,4185],[4188,4188]]],[1553514704511,["28447@DESKTOP-BE7HQ26",[[1,4188,"language\n```\n"]],[4188,4188],[4188,4196]]],[1553514705868,["28447@DESKTOP-BE7HQ26",[[-1,4188,"language"],[1,4196,"j"]],[4188,4196],[4189,4189]]],[1553514706384,["28447@DESKTOP-BE7HQ26",[[1,4189,"ava"]],[4189,4189],[4192,4192]]],[1553514706728,["28447@DESKTOP-BE7HQ26",[[1,4193,"\n"]],[4192,4192],[4193,4193]]],[1553514707148,["28447@DESKTOP-BE7HQ26",[[1,4193,"public class TestFailFast {\n    \n    private static final String USER_NAME_PREFIX = \"User-\";\n    // Key: User Name, Value: User Age\n    private static Map<String, Integer> userMap = new HashMap<>();\n    \n    // ThreadA 用于向HashMap添加元素\n    static class ThreadA implements Runnable {\n        @Override\n        public void run() {\n            System.out.println(\"ThreadA starts to add user.\");\n            for (int i = 1; i < 100000; i++) {\n                userMap.put(USER_NAME_PREFIX+i, i%100);\n            }\n            System.out.println(\"ThreadA done.\");\n        }\n    }\n    \n    // ThreadB 用于遍历HashMap中元素输出\n    static class ThreadB implements Runnable {\n        @Override\n        public void run() {\n            System.out.println(\"ThreadB starts to iterate.\");\n            for (Map.Entry<String, Integer> user : userMap.entrySet()) {\n                System.out.println(\"UserName=\" + user.getKey()\n                    + \", UserAge=\" + user.getValue());\n            }\n            System.out.println(\"ThreadB done.\");\n        }\n    }\n    \n    public static void main(String[] args) throws InterruptedException {\n        Thread threadA = new Thread(new ThreadA());\n        Thread threadB = new Thread(new ThreadB());\n    \n        threadA.start();\n        threadB.start();\n  \n        threadA.join();\n        threadB.join();\n        System.exit(0);\n    }\n}"]],[4193,4193],[5546,5546]]],[1553514714065,["28447@DESKTOP-BE7HQ26",[[1,5563,"\n"]],[5550,5550],[5551,5551]]],[1553514717715,["28447@DESKTOP-BE7HQ26",[[1,5551,"运行结果：抛出ConcurrentModificationException"]],[5551,5551],[5589,5589]]],[1553515868650,["28447@DESKTOP-BE7HQ26",[[1,6382,"\n\n"]],[6382,6382],[6383,6383]]],[1553515868824,["28447@DESKTOP-BE7HQ26",[[1,6384,"\n"]],[6383,6383],[6384,6384]]],[1553515869010,["28447@DESKTOP-BE7HQ26",[[1,6385,"\n"]],[6384,6384],[6385,6385]]],[1553515870722,["28447@DESKTOP-BE7HQ26",[[-1,6385,"\n"],[1,6386,"#"]],[6385,6385],[6386,6386]]],[1553515877781,["28447@DESKTOP-BE7HQ26",[[1,6386,"## TCP三次握手u"]],[6386,6386],[6397,6397]]],[1553515878578,["28447@DESKTOP-BE7HQ26",[[-1,6396,"u"]],[6397,6397],[6396,6396]]],[1553515878831,["28447@DESKTOP-BE7HQ26",[[1,6396,"\n\n"]],[6396,6396],[6397,6397]]],[1553515885199,["28447@DESKTOP-BE7HQ26",[[1,6389,"****"]],[6389,6389],[6391,6391]]],[1553515887391,["28447@DESKTOP-BE7HQ26",[[-1,6393,"TCP三次握手"]],[6393,6400],[6393,6393]]],[1553515888886,["28447@DESKTOP-BE7HQ26",[[1,6391,"TCP三次握手"]],[6391,6391],[6398,6398]]],[1553515890451,["28447@DESKTOP-BE7HQ26",[[1,6402,"\n"]],[6400,6400],[6401,6401]]],[1553515890634,["28447@DESKTOP-BE7HQ26",[[1,6403,"\n"]],[6401,6401],[6402,6402]]],[1553515894530,["28447@DESKTOP-BE7HQ26",[[1,6402,"### ****"]],[6402,6402],[6408,6408]]],[1553515897820,["28447@DESKTOP-BE7HQ26",[[1,6408,"TCPsi"]],[6408,6408],[6413,6413]]],[1553515898535,["28447@DESKTOP-BE7HQ26",[[-1,6411,"si"]],[6413,6413],[6411,6411]]],[1553515902553,["28447@DESKTOP-BE7HQ26",[[1,6411,"四次挥手"]],[6411,6411],[6415,6415]]],[1553515903556,["28447@DESKTOP-BE7HQ26",[[1,6419,"\n"]],[6417,6417],[6418,6418]]],[1553515971446,["28447@DESKTOP-BE7HQ26",[[1,6402,"\n"]],[6401,6401],[6402,6402]]],[1553515971706,["28447@DESKTOP-BE7HQ26",[[1,6403,"\n"]],[6402,6402],[6403,6403]]],[1553516007335,["28447@DESKTOP-BE7HQ26",[[1,6401,"- 第一次握手：建立连接时，客户端发送syn（Synchronize Sequence Numbers：同步序列编号）包（sny=1）到服务器，并进入SYN_SEND（请求连接）状态，等待服务器确认;\n                  第二次握手：服务器接收到syn包，必须确认客户的syn（ack=j+1）（ack：确认字符，表示发来的数据已确认接收无误），同时自己也发送一个syn包（sny=k），既ack+syn包，此时服务器进入SYN_RECV（发送了ACK时的状态）状态。\n                  第三次握手：客户端收到服务端发送的syn+ack包，向服务端发送确认包ack（sny+1既ack=k+1），此包发送完毕，客户端与服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n--------------------- \n作者：郑先生@樊小姐 \n来源：CSDN \n原文：https://blog.csdn.net/zhengzhaoyang122/article/details/82184072 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[6401,6401],[6900,6900]]],[1553516012955,["28447@DESKTOP-BE7HQ26",[[-1,6503,"                 "]],[6520,6520],[6503,6503]]],[1553516014386,["28447@DESKTOP-BE7HQ26",[[-1,6502," "],[1,6503," -"],[-1,6627,"                 "],[1,6644,"                 "]],[6503,6503],[6504,6504]]],[1553516015081,["28447@DESKTOP-BE7HQ26",[[1,6504," "]],[6504,6504],[6505,6505]]],[1553516019733,["28447@DESKTOP-BE7HQ26",[[-1,6629,"                  "]],[6629,6647],[6629,6629]]],[1553516020257,["28447@DESKTOP-BE7HQ26",[[1,6629,"- "]],[6629,6629],[6631,6631]]],[1553516023405,["28447@DESKTOP-BE7HQ26",[[1,6629,"  "]],[6629,6629],[6631,6631]]],[1553516024738,["28447@DESKTOP-BE7HQ26",[[1,6401,"  "]],[6401,6401],[6403,6403]]],[1553516026232,["28447@DESKTOP-BE7HQ26",[[1,6505," "]],[6505,6505],[6506,6506]]],[1553516031531,["28447@DESKTOP-BE7HQ26",[[-1,6737,"--------------------- \n作者：郑先生@樊小姐 \n来源：CSDN \n原文：https://blog.csdn.net/zhengzhaoyang122/article/details/82184072 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[6737,6874],[6737,6737]]],[1553516036082,["28447@DESKTOP-BE7HQ26",[[1,6737,"![](https://img-blog.csdn.net/20180830135313575?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nemhhb3lhbmcxMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)"]],[6737,6737],[6912,6912]]],[1553516039536,["28447@DESKTOP-BE7HQ26",[[1,6737,"  - \n"]],[6736,6736],[6741,6741]]],[1553516042158,["28447@DESKTOP-BE7HQ26",[[-1,6739,"- "]],[6741,6741],[6739,6739]]],[1553516044845,["28447@DESKTOP-BE7HQ26",[[1,6918,"\n"]],[6915,6915],[6916,6916]]],[1553516045064,["28447@DESKTOP-BE7HQ26",[[1,6919,"\n"]],[6916,6916],[6917,6917]]],[1553516277600,["28447@DESKTOP-BE7HQ26",[[1,6742,"_TCP三次握手图_"]],[6742,6742],[6752,6752]]],[1553516281636,["28447@DESKTOP-BE7HQ26",[[-1,6751,"_"]],[6752,6752],[6751,6751]]],[1553516283722,["28447@DESKTOP-BE7HQ26",[[-1,6742,"_"]],[6743,6743],[6742,6742]]],[1553516289118,["28447@DESKTOP-BE7HQ26",[[1,6928,"\n"]],[6923,6923],[6924,6924]]],[1553516289459,["28447@DESKTOP-BE7HQ26",[[1,6929,"\n"]],[6924,6924],[6925,6925]]],[1553516293424,["28447@DESKTOP-BE7HQ26",[[-1,6929,"\n"]],[6929,6929],[6928,6928]]],[1553516293659,["28447@DESKTOP-BE7HQ26",[[-1,6928,"\n"]],[6928,6928],[6927,6927]]],[1553516293937,["28447@DESKTOP-BE7HQ26",[[-1,6927,"\n"]],[6927,6927],[6926,6926]]],[1553516294355,["28447@DESKTOP-BE7HQ26",[[-1,6926,"\n"]],[6926,6926],[6925,6925]]],[1553516295526,["28447@DESKTOP-BE7HQ26",[[1,6944,"\n"]],[6941,6941],[6942,6942]]],[1553516374046,["28447@DESKTOP-BE7HQ26",[[1,6943,"                   第一次挥手：TCP客户端发送一个FIN+ACK+SEQ，用来传输关闭客户端到服务端的数据。进入FIN_WAIT1状态。\n                   第二次挥手：服务端收到FIN，被动发送一个ACK（SEQ+1）,进入CLOSE_WAIT状态，客户端收到服务端发送的ACK，进入FIN_WAIT2状态。\n                   第三次挥手：服务器关闭客户端连接，发送一个FIN给+ACK+SEQ客户端。进入LAST_ACK状态。\n                   第四次挥手：客户端发送ACK（ACK=SQE序号+1）报文确认，客户端进入TIME_WAIT状态，服务端收到ACK进入CLOSE状态。\n--------------------- \n作者：郑先生@樊小姐 \n来源：CSDN \n原文：https://blog.csdn.net/zhengzhaoyang122/article/details/82184072 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[6943,6943],[7412,7412]]],[1553516376916,["28447@DESKTOP-BE7HQ26",[[-1,6943,"                   "]],[6943,6962],[6943,6943]]],[1553516377347,["28447@DESKTOP-BE7HQ26",[[1,6943,"-"],[-1,7003,"                  "],[1,7021,"                  "],[-1,7099,"                  "],[1,7117,"                  "],[-1,7169,"                  "],[1,7187,"                  "]],[6943,6943],[6944,6944]]],[1553516377828,["28447@DESKTOP-BE7HQ26",[[1,6944," "]],[6944,6944],[6945,6945]]],[1553516379363,["28447@DESKTOP-BE7HQ26",[[1,6943,"  "]],[6943,6943],[6945,6945]]],[1553516382719,["28447@DESKTOP-BE7HQ26",[[-1,7007,"                   "]],[7007,7026],[7007,7007]]],[1553516383961,["28447@DESKTOP-BE7HQ26",[[1,7007,"- "]],[7007,7007],[7009,7009]]],[1553516385232,["28447@DESKTOP-BE7HQ26",[[1,7007,"  "]],[7007,7007],[7009,7009]]],[1553516397714,["28447@DESKTOP-BE7HQ26",[[-1,7088,"                   "]],[7088,7107],[7088,7088]]],[1553516398279,["28447@DESKTOP-BE7HQ26",[[1,7088,"- "]],[7088,7088],[7090,7090]]],[1553516401183,["28447@DESKTOP-BE7HQ26",[[-1,7141,"                   "]],[7141,7160],[7141,7141]]],[1553516401619,["28447@DESKTOP-BE7HQ26",[[1,7141,"- "]],[7141,7141],[7143,7143]]],[1553516402948,["28447@DESKTOP-BE7HQ26",[[1,7141,"  "]],[7141,7141],[7143,7143]]],[1553516404719,["28447@DESKTOP-BE7HQ26",[[1,7088,"  "]],[7088,7088],[7090,7090]]],[1553516409681,["28447@DESKTOP-BE7HQ26",[[-1,7215,"--------------------- \n作者：郑先生@樊小姐 \n来源：CSDN \n原文：https://blog.csdn.net/zhengzhaoyang122/article/details/82184072 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[7215,7352],[7215,7215]]],[1553516410733,["28447@DESKTOP-BE7HQ26",[[1,7217,"\n"]],[7215,7215],[7216,7216]]],[1553516415634,["28447@DESKTOP-BE7HQ26",[[1,7215,"![](https://img-blog.csdn.net/20180830142208139?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nemhhb3lhbmcxMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)"]],[7215,7215],[7390,7390]]],[1553516418736,["28447@DESKTOP-BE7HQ26",[[1,7215,"  - \n"]],[7214,7214],[7219,7219]]],[1553516420536,["28447@DESKTOP-BE7HQ26",[[-1,7217,"- "]],[7219,7219],[7217,7217]]],[1553516654026,["28447@DESKTOP-BE7HQ26",[[1,7396,"\n"]],[7395,7395],[7396,7396]]],[1553516655253,["28447@DESKTOP-BE7HQ26",[[-1,7396,"\n"],[1,7397,"#"]],[7396,7396],[7397,7397]]],[1553516655790,["28447@DESKTOP-BE7HQ26",[[1,7397,"###"]],[7397,7397],[7400,7400]]],[1553516656444,["28447@DESKTOP-BE7HQ26",[[-1,7399,"#"]],[7400,7400],[7399,7399]]],[1553516657690,["28447@DESKTOP-BE7HQ26",[[1,7399,"       ☆ 200 OK：表示客户端请求成功。\n      ☆ 400 Bad Request 语义有误，不能被当前服务器理解。\n      ☆ 401 Unauthorized 当前请求需要用户验证。\n      ☆ 403 Forbidden 服务器收到消息，但是拒绝提供服务。\n      ☆ 404 Not Found 请求资源不存在。\n      ☆ 408 Request Timeout 请求超时，客户端没有在服务器预备等待的时间内完成发送。\n      ☆ 500 Internal Server Error 服务器发生不可预期的错误。\n      ☆ 503 Server Unavailable 由于临时的服务器维护或过载，服务器当前不能处理请求，此状况知识临时的，可恢复\n--------------------- \n作者：郑先生@樊小姐 \n来源：CSDN \n原文：https://blog.csdn.net/zhengzhaoyang122/article/details/82184072 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[7399,7399],[7886,7886]]],[1553516658670,["28447@DESKTOP-BE7HQ26",[[-1,7399,"       ☆ 200 OK：表示客户端请求成功。\n      ☆ 400 Bad Request 语义有误，不能被当前服务器理解。\n      ☆ 401 Unauthorized 当前请求需要用户验证。\n      ☆ 403 Forbidden 服务器收到消息，但是拒绝提供服务。\n      ☆ 404 Not Found 请求资源不存在。\n      ☆ 408 Request Timeout 请求超时，客户端没有在服务器预备等待的时间内完成发送。\n      ☆ 500 Internal Server Error 服务器发生不可预期的错误。\n      ☆ 503 Server Unavailable 由于临时的服务器维护或过载，服务器当前不能处理请求，此状况知识临时的，可恢复\n--------------------- \n作者：郑先生@樊小姐 \n来源：CSDN \n原文：https://blog.csdn.net/zhengzhaoyang122/article/details/82184072 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[7886,7886],[7399,7399]]],[1553516663194,["28447@DESKTOP-BE7HQ26",[[1,7399," 硕鼠"]],[7399,7399],[7402,7402]]],[1553516663943,["28447@DESKTOP-BE7HQ26",[[-1,7400,"硕鼠"]],[7402,7402],[7400,7400]]],[1553516667463,["28447@DESKTOP-BE7HQ26",[[1,7400,"说说及中国"]],[7400,7400],[7405,7405]]],[1553516668795,["28447@DESKTOP-BE7HQ26",[[-1,7402,"及中国"]],[7405,7405],[7402,7402]]],[1553516674458,["28447@DESKTOP-BE7HQ26",[[1,7402,"几种HTTPxian"]],[7402,7402],[7412,7412]]],[1553516675357,["28447@DESKTOP-BE7HQ26",[[-1,7408,"xian"]],[7412,7412],[7408,7408]]],[1553516678517,["28447@DESKTOP-BE7HQ26",[[1,7408,"响应码"]],[7408,7408],[7411,7411]]],[1553516679967,["28447@DESKTOP-BE7HQ26",[[1,7411,"\n\n"]],[7411,7411],[7412,7412]]],[1553516680336,["28447@DESKTOP-BE7HQ26",[[1,7412,"      ☆ 200 OK：表示客户端请求成功。\n      ☆ 400 Bad Request 语义有误，不能被当前服务器理解。\n      ☆ 401 Unauthorized 当前请求需要用户验证。\n      ☆ 403 Forbidden 服务器收到消息，但是拒绝提供服务。\n      ☆ 404 Not Found 请求资源不存在。\n      ☆ 408 Request Timeout 请求超时，客户端没有在服务器预备等待的时间内完成发送。\n      ☆ 500 Internal Server Error 服务器发生不可预期的错误。\n      ☆ 503 Server Unavailable 由于临时的服务器维护或过载，服务器当前不能处理请求，此状况知识临时的，可恢复\n--------------------- \n作者：郑先生@樊小姐 \n来源：CSDN \n原文：https://blog.csdn.net/zhengzhaoyang122/article/details/82184072 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[7412,7412],[7898,7898]]],[1553516689484,["28447@DESKTOP-BE7HQ26",[[-1,7400,"说说几种HTTP响应码"]],[7400,7411],[7400,7400]]],[1553516690623,["28447@DESKTOP-BE7HQ26",[[-1,7400,"\n     "],[1,7406,"*\n     "],[-1,7427,"     "],[1,7432,"     "],[-1,7468,"     "],[1,7473,"     "],[-1,7505,"     "],[1,7510,"     "],[-1,7545,"     "],[1,7550,"     "],[-1,7576,"     "],[1,7581,"     "],[-1,7632,"     "],[1,7637,"     "],[-1,7680,"     "],[1,7685,"     "]],[7400,7400],[7401,7401]]],[1553516690832,["28447@DESKTOP-BE7HQ26",[[1,7401,"***"]],[7401,7401],[7402,7402]]],[1553516691242,["28447@DESKTOP-BE7HQ26",[[1,7402,"说说几种HTTP响应码"]],[7402,7402],[7413,7413]]],[1553516695273,["28447@DESKTOP-BE7HQ26",[[1,7416,"\n"]],[7415,7415],[7416,7416]]],[1553516698270,["28447@DESKTOP-BE7HQ26",[[-1,7416,"\n"]],[7416,7416],[7415,7415]]],[1553516701371,["28447@DESKTOP-BE7HQ26",[[-1,7765,"--------------------- \n作者：郑先生@樊小姐 \n来源：CSDN \n原文：https://blog.csdn.net/zhengzhaoyang122/article/details/82184072 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[7765,7902],[7765,7765]]],[1553516719682,["28447@DESKTOP-BE7HQ26",[[1,7766,"\n"]],[7765,7765],[7766,7766]]],[1553516720567,["28447@DESKTOP-BE7HQ26",[[-1,7766,"\n"],[1,7767,"#"]],[7766,7766],[7767,7767]]],[1553516722751,["28447@DESKTOP-BE7HQ26",[[1,7767,"## ****"]],[7767,7767],[7772,7772]]],[1553516727880,["28447@DESKTOP-BE7HQ26",[[1,7772,"当你打开"]],[7772,7772],[7776,7776]]],[1553516730235,["28447@DESKTOP-BE7HQ26",[[-1,7772,"当你打开"]],[7776,7776],[7772,7772]]],[1553516742313,["28447@DESKTOP-BE7HQ26",[[1,7772,"当你用浏览器打开一个连接"]],[7772,7772],[7784,7784]]],[1553516743009,["28447@DESKTOP-BE7HQ26",[[-1,7782,"连接"]],[7784,7784],[7782,7782]]],[1553516754941,["28447@DESKTOP-BE7HQ26",[[1,7782,"链接时，计算机做了哪些步骤"]],[7782,7782],[7795,7795]]],[1553516756061,["28447@DESKTOP-BE7HQ26",[[1,7797,"\n\n"]],[7797,7797],[7798,7798]]],[1553516775680,["28447@DESKTOP-BE7HQ26",[[1,7799,"- "]],[7799,7799],[7801,7801]]],[1553516777385,["28447@DESKTOP-BE7HQ26",[[-1,7798,"\n"]],[7799,7799],[7798,7798]]],[1553516778478,["28447@DESKTOP-BE7HQ26",[[1,7798,"  "]],[7798,7798],[7800,7800]]],[1553516779823,["28447@DESKTOP-BE7HQ26",[[1,7802," "]],[7801,7801],[7802,7802]]],[1553516786621,["28447@DESKTOP-BE7HQ26",[[1,7802,"1、解析域名\n  "]],[7802,7802],[7811,7811]]],[1553516787486,["28447@DESKTOP-BE7HQ26",[[1,7812,"  "]],[7811,7811],[7813,7813]]],[1553516788533,["28447@DESKTOP-BE7HQ26",[[-1,7812,"  "]],[7813,7813],[7811,7811]]],[1553516788876,["28447@DESKTOP-BE7HQ26",[[1,7811,"-"]],[7811,7811],[7812,7812]]],[1553516789871,["28447@DESKTOP-BE7HQ26",[[1,7813," "]],[7812,7812],[7813,7813]]],[1553516796173,["28447@DESKTOP-BE7HQ26",[[1,7813,"2、发次TCPd"]],[7813,7813],[7821,7821]]],[1553516796649,["28447@DESKTOP-BE7HQ26",[[-1,7820,"d"]],[7821,7821],[7820,7820]]],[1553516797032,["28447@DESKTOP-BE7HQ26",[[1,7820,"x"]],[7820,7820],[7821,7821]]],[1553516797578,["28447@DESKTOP-BE7HQ26",[[-1,7820,"x"]],[7821,7821],[7820,7820]]],[1553516803113,["28447@DESKTOP-BE7HQ26",[[1,7820,"的3次握手\n  "]],[7820,7820],[7828,7828]]],[1553516804279,["28447@DESKTOP-BE7HQ26",[[1,7829," "]],[7828,7828],[7829,7829]]],[1553516804583,["28447@DESKTOP-BE7HQ26",[[1,7829,"-"]],[7829,7829],[7830,7830]]],[1553516805524,["28447@DESKTOP-BE7HQ26",[[-1,7829,"- "]],[7830,7830],[7828,7828]]],[1553516806033,["28447@DESKTOP-BE7HQ26",[[1,7829," "]],[7828,7828],[7829,7829]]],[1553516806459,["28447@DESKTOP-BE7HQ26",[[1,7829,"-"]],[7829,7829],[7830,7830]]],[1553516807487,["28447@DESKTOP-BE7HQ26",[[-1,7829,"- "]],[7830,7830],[7828,7828]]],[1553516808604,["28447@DESKTOP-BE7HQ26",[[1,7828,"="]],[7828,7828],[7829,7829]]],[1553516809192,["28447@DESKTOP-BE7HQ26",[[-1,7828,"="]],[7829,7829],[7828,7828]]],[1553516809734,["28447@DESKTOP-BE7HQ26",[[1,7828,"-"]],[7828,7828],[7829,7829]]],[1553516810580,["28447@DESKTOP-BE7HQ26",[[1,7830," "]],[7829,7829],[7830,7830]]],[1553516817276,["28447@DESKTOP-BE7HQ26",[[1,7830,"3、建立TCPqin"]],[7830,7830],[7840,7840]]],[1553516818080,["28447@DESKTOP-BE7HQ26",[[-1,7837,"qin"]],[7840,7840],[7837,7837]]],[1553516824807,["28447@DESKTOP-BE7HQ26",[[1,7837,"请求后发起"]],[7837,7837],[7842,7842]]],[1553516831477,["28447@DESKTOP-BE7HQ26",[[1,7842,"HTTPqi"]],[7842,7842],[7848,7848]]],[1553516832037,["28447@DESKTOP-BE7HQ26",[[-1,7846,"qi"]],[7848,7848],[7846,7846]]],[1553516836638,["28447@DESKTOP-BE7HQ26",[[1,7846,"请求\n  -"]],[7846,7846],[7852,7852]]],[1553516837348,["28447@DESKTOP-BE7HQ26",[[1,7853," "]],[7852,7852],[7853,7853]]],[1553516838116,["28447@DESKTOP-BE7HQ26",[[1,7853,"3、"]],[7853,7853],[7855,7855]]],[1553516838491,["28447@DESKTOP-BE7HQ26",[[-1,7854,"、"]],[7855,7855],[7854,7854]]],[1553516838863,["28447@DESKTOP-BE7HQ26",[[1,7854,"4、"]],[7854,7854],[7856,7856]]],[1553516839670,["28447@DESKTOP-BE7HQ26",[[-1,7853,"34、"]],[7856,7856],[7853,7853]]],[1553516859325,["28447@DESKTOP-BE7HQ26",[[1,7853,"4、服务器相应的HTTPqi"]],[7853,7853],[7867,7867]]],[1553516859965,["28447@DESKTOP-BE7HQ26",[[-1,7865,"qi"]],[7867,7867],[7865,7865]]],[1553516882373,["28447@DESKTOP-BE7HQ26",[[1,7865,"请求\n  -"]],[7865,7865],[7871,7871]]],[1553516883253,["28447@DESKTOP-BE7HQ26",[[1,7872," "]],[7871,7871],[7872,7872]]],[1553516884900,["28447@DESKTOP-BE7HQ26",[[1,7872,"5、"]],[7872,7872],[7874,7874]]],[1553516890744,["28447@DESKTOP-BE7HQ26",[[1,7874,"浏览器德奥"]],[7874,7874],[7879,7879]]],[1553516891606,["28447@DESKTOP-BE7HQ26",[[-1,7877,"德奥"]],[7879,7879],[7877,7877]]],[1553516896757,["28447@DESKTOP-BE7HQ26",[[1,7877,"得到HTMLdai"]],[7877,7877],[7886,7886]]],[1553516897612,["28447@DESKTOP-BE7HQ26",[[-1,7883,"dai"]],[7886,7886],[7883,7883]]],[1553516898738,["28447@DESKTOP-BE7HQ26",[[1,7883,"带啊吗"]],[7883,7883],[7886,7886]]],[1553516899711,["28447@DESKTOP-BE7HQ26",[[-1,7883,"带啊吗"]],[7886,7886],[7883,7883]]],[1553516907138,["28447@DESKTOP-BE7HQ26",[[1,7883,"代码，进行解析个"]],[7883,7883],[7891,7891]]],[1553516907529,["28447@DESKTOP-BE7HQ26",[[-1,7890,"个"]],[7891,7891],[7890,7890]]],[1553516911783,["28447@DESKTOP-BE7HQ26",[[1,7890,"和处理JDSON"]],[7890,7890],[7898,7898]]],[1553516912654,["28447@DESKTOP-BE7HQ26",[[-1,7894,"DSON"]],[7898,7898],[7894,7894]]],[1553516924239,["28447@DESKTOP-BE7HQ26",[[1,7894,"SON数据，并请求HTMLdai"]],[7894,7894],[7910,7910]]],[1553516925168,["28447@DESKTOP-BE7HQ26",[[-1,7907,"dai"]],[7910,7910],[7907,7907]]],[1553516934828,["28447@DESKTOP-BE7HQ26",[[1,7907,"代码中的静态资源（——"]],[7907,7907],[7918,7918]]],[1553516936089,["28447@DESKTOP-BE7HQ26",[[-1,7916,"——"]],[7918,7918],[7916,7916]]],[1553516936787,["28447@DESKTOP-BE7HQ26",[[1,7916,"）"]],[7916,7916],[7917,7917]]],[1553516940491,["28447@DESKTOP-BE7HQ26",[[1,7916,"JS\\"]],[7916,7916],[7919,7919]]],[1553516941455,["28447@DESKTOP-BE7HQ26",[[-1,7918,"\\"]],[7919,7919],[7918,7918]]],[1553516943443,["28447@DESKTOP-BE7HQ26",[[1,7918,"\\"]],[7918,7918],[7919,7919]]],[1553516944119,["28447@DESKTOP-BE7HQ26",[[-1,7918,"\\"]],[7919,7919],[7918,7918]]],[1553516946520,["28447@DESKTOP-BE7HQ26",[[1,7918,"、CSS\\"]],[7918,7918],[7923,7923]]],[1553516947247,["28447@DESKTOP-BE7HQ26",[[-1,7922,"\\"]],[7923,7923],[7922,7922]]],[1553516947628,["28447@DESKTOP-BE7HQ26",[[1,7922,"、"]],[7922,7922],[7923,7923]]],[1553516951069,["28447@DESKTOP-BE7HQ26",[[1,7923,"图片等"]],[7923,7923],[7926,7926]]],[1553516954017,["28447@DESKTOP-BE7HQ26",[[1,7927,"\n  -6"]],[7927,7927],[7932,7932]]],[1553516955199,["28447@DESKTOP-BE7HQ26",[[-1,7931,"6"]],[7932,7932],[7931,7931]]],[1553516955394,["28447@DESKTOP-BE7HQ26",[[1,7932," "]],[7931,7931],[7932,7932]]],[1553516956957,["28447@DESKTOP-BE7HQ26",[[1,7932,"、"]],[7932,7932],[7933,7933]]],[1553516958198,["28447@DESKTOP-BE7HQ26",[[1,7932,"6"]],[7932,7932],[7933,7933]]],[1553516959887,["28447@DESKTOP-BE7HQ26",[[1,7934,"；"]],[7934,7934],[7935,7935]]],[1553516961415,["28447@DESKTOP-BE7HQ26",[[-1,7934,"；"]],[7935,7935],[7934,7934]]],[1553516969275,["28447@DESKTOP-BE7HQ26",[[1,7934,"浏览器对页面惊醒"]],[7934,7934],[7942,7942]]],[1553516970151,["28447@DESKTOP-BE7HQ26",[[-1,7940,"惊醒"]],[7942,7942],[7940,7940]]],[1553516977416,["28447@DESKTOP-BE7HQ26",[[1,7940,"进行绚烂"]],[7940,7940],[7944,7944]]],[1553516978176,["28447@DESKTOP-BE7HQ26",[[-1,7942,"绚烂"]],[7944,7944],[7942,7942]]],[1553516983495,["28447@DESKTOP-BE7HQ26",[[1,7942,"渲染"]],[7942,7942],[7944,7944]]],[1553516994520,["28447@DESKTOP-BE7HQ26",[[1,6385,"\n"]],[6383,6383],[6384,6384]]],[1553516998235,["28447@DESKTOP-BE7HQ26",[[1,6384,"## ****"]],[6384,6384],[6389,6389]]],[1553517001536,["28447@DESKTOP-BE7HQ26",[[1,6389,"网络"]],[6389,6389],[6391,6391]]],[1553517104093,["28447@DESKTOP-BE7HQ26",[[1,7955,"\n  - "]],[7955,7955],[7960,7960]]],[1553517104310,["28447@DESKTOP-BE7HQ26",[[-1,7956,"  - "],[1,7960,"\n\n"]],[7960,7960],[7957,7957]]],[1553517176258,["28447@DESKTOP-BE7HQ26",[[-1,7957,"\n"],[1,7958,"【"]],[7957,7957],[7958,7958]]],[1553517176667,["28447@DESKTOP-BE7HQ26",[[1,7958,"】"]],[7958,7958],[7959,7959]]],[1553517177089,["28447@DESKTOP-BE7HQ26",[[-1,7958,"】"]],[7959,7959],[7958,7958]]],[1553517177276,["28447@DESKTOP-BE7HQ26",[[-1,7957,"【"],[1,7958,"\n"]],[7958,7958],[7957,7957]]],[1553517177914,["28447@DESKTOP-BE7HQ26",[[-1,7957,"\n"],[1,7958,"["]],[7957,7957],[7958,7958]]],[1553517178107,["28447@DESKTOP-BE7HQ26",[[1,7958,"]"]],[7958,7958],[7959,7959]]],[1553517181898,["28447@DESKTOP-BE7HQ26",[[1,7958,"网络只是"]],[7958,7958],[7962,7962]]],[1553517182847,["28447@DESKTOP-BE7HQ26",[[-1,7960,"只是"]],[7962,7962],[7960,7960]]],[1553517189856,["28447@DESKTOP-BE7HQ26",[[1,7960,"面试知识点"]],[7960,7960],[7965,7965]]],[1553517191537,["28447@DESKTOP-BE7HQ26",[[1,7966,"("]],[7966,7966],[7967,7967]]],[1553517191591,["28447@DESKTOP-BE7HQ26",[[1,7967,"https://)"]],[7967,7967],[7967,7975]]],[1553517199595,["28447@DESKTOP-BE7HQ26",[[1,7975,"blog.csdn.net/zhengzhaoyang122/article/details/82184072"]],[7967,7975],[8030,8030]]],[1553517202517,["28447@DESKTOP-BE7HQ26",[[1,8031,"\n\n"]],[8031,8031],[8032,8032]]],[1553517203559,["28447@DESKTOP-BE7HQ26",[[-1,8032,"\n"],[1,8033,"["]],[8032,8032],[8033,8033]]],[1553517203769,["28447@DESKTOP-BE7HQ26",[[1,8033,"]"]],[8033,8033],[8034,8034]]],[1553517205192,["28447@DESKTOP-BE7HQ26",[[1,8033,"wa"]],[8033,8033],[8035,8035]]],[1553517205929,["28447@DESKTOP-BE7HQ26",[[-1,8033,"wa"]],[8035,8035],[8033,8033]]],[1553517213963,["28447@DESKTOP-BE7HQ26",[[1,8033,"网络面试知识点2"]],[8033,8033],[8041,8041]]],[1553517215470,["28447@DESKTOP-BE7HQ26",[[1,8042,"（"]],[8042,8042],[8043,8043]]],[1553517216425,["28447@DESKTOP-BE7HQ26",[[-1,8042,"（"]],[8043,8043],[8042,8042]]],[1553517217626,["28447@DESKTOP-BE7HQ26",[[1,8042,"("]],[8042,8042],[8043,8043]]],[1553517217667,["28447@DESKTOP-BE7HQ26",[[1,8043,"https://)"]],[8043,8043],[8043,8051]]],[1553517225290,["28447@DESKTOP-BE7HQ26",[[1,8051,"www.cnblogs.com/huajiezh/p/7492416.html"]],[8043,8051],[8090,8090]]],[1553517240096,["28447@DESKTOP-BE7HQ26",[[1,7965,"1"]],[7965,7965],[7966,7966]]],[1553517423526,["28447@DESKTOP-BE7HQ26",[[1,8092,"\n\n"]],[8092,8092],[8093,8093]]],[1553517423713,["28447@DESKTOP-BE7HQ26",[[1,8094,"\n"]],[8093,8093],[8094,8094]]],[1553517426350,["28447@DESKTOP-BE7HQ26",[[-1,8094,"\n"],[1,8095,"#"]],[8094,8094],[8095,8095]]],[1553517429799,["28447@DESKTOP-BE7HQ26",[[1,8095,"## ****"]],[8095,8095],[8100,8100]]],[1553517430265,["28447@DESKTOP-BE7HQ26",[[1,8100,"TCP，UDP区别，为什么可靠和不可靠"]],[8100,8100],[8119,8119]]],[1553517432504,["28447@DESKTOP-BE7HQ26",[[1,8121,"\n\n"]],[8121,8121],[8122,8122]]],[1553517521171,["28447@DESKTOP-BE7HQ26",[[1,8123,"\n"]],[8121,8121],[8122,8122]]],[1553517521415,["28447@DESKTOP-BE7HQ26",[[1,8124,"\n"]],[8122,8122],[8123,8123]]],[1553517526056,["28447@DESKTOP-BE7HQ26",[[1,8122,"\t\nTCP\n\nUDP\n\n连接方式\n\n点到点\n\n一对一，一对多，多对一，多对多\n\n是否连接\n\n面向连接\n\n无连接\n\n传输是否可靠性\n\n可靠，无差错不丢失不重复\n\n不可靠\n\n是否有拥塞控制\n\n面向字节流，有拥塞控制\n\n面向报文，无拥塞控制（实时性好，如IP电话，实时视频会议）\n\n速度\n\n慢\n\n快\n\n应用场合\n\n传递大量数据\n\n传递少量数据\n\n首部开销\n\n大，20B\n\n小,8B\n\n逻辑通信信道\n\n全双工的可靠信道\n\n不可靠信道\n--------------------- \n作者：筑梦悠然 \n来源：CSDN \n原文：https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78507826 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[8122,8122],[8469,8469]]],[1553517540988,["28447@DESKTOP-BE7HQ26",[[-1,8122,"\t\nTCP\n\nUDP\n\n连接方式\n\n点到点\n\n一对一，一对多，多对一，多对多\n\n是否连接\n\n面向连接\n\n无连接\n\n传输是否可靠性\n\n可靠，无差错不丢失不重复\n\n不可靠\n\n是否有拥塞控制\n\n面向字节流，有拥塞控制\n\n面向报文，无拥塞控制（实时性好，如IP电话，实时视频会议）\n\n速度\n\n慢\n\n快\n\n应用场合\n\n传递大量数据\n\n传递少量数据\n\n首部开销\n\n大，20B\n\n小,8B\n\n逻辑通信信道\n\n全双工的可靠信道\n\n不可靠信道\n--------------------- \n作者：筑梦悠然 \n来源：CSDN \n原文：https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78507826 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[8469,8469],[8122,8122]]],[1553517541673,["28447@DESKTOP-BE7HQ26",[[1,8122," \n\nTCP\n\nUDP\n\n连接方式\n\n点到点\n\n一对一，一对多，多对一，多对多\n\n是否连接\n\n面向连接\n\n无连接\n\n传输是否可靠性\n\n可靠，无差错不丢失不重复\n\n不可靠\n\n是否有拥塞控制\n\n面向字节流，有拥塞控制\n\n面向报文，无拥塞控制（实时性好，如IP电话，实时视频会议）\n\n速度\n\n慢\n\n快\n\n应用场合\n\n传递大量数据\n\n传递少量数据\n\n首部开销\n\n大，20B\n\n小,8B\n\n逻辑通信信道\n\n全双工的可靠信道\n\n不可靠信道\n--------------------- \n作者：筑梦悠然 \n来源：CSDN \n原文：https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78507826 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[8122,8122],[8470,8470]]],[1553517542927,["28447@DESKTOP-BE7HQ26",[[-1,8122," \n\nTCP\n\nUDP\n\n连接方式\n\n点到点\n\n一对一，一对多，多对一，多对多\n\n是否连接\n\n面向连接\n\n无连接\n\n传输是否可靠性\n\n可靠，无差错不丢失不重复\n\n不可靠\n\n是否有拥塞控制\n\n面向字节流，有拥塞控制\n\n面向报文，无拥塞控制（实时性好，如IP电话，实时视频会议）\n\n速度\n\n慢\n\n快\n\n应用场合\n\n传递大量数据\n\n传递少量数据\n\n首部开销\n\n大，20B\n\n小,8B\n\n逻辑通信信道\n\n全双工的可靠信道\n\n不可靠信道\n--------------------- \n作者：筑梦悠然 \n来源：CSDN \n原文：https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78507826 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[8470,8470],[8122,8122]]],[1553517679886,["28447@DESKTOP-BE7HQ26",[[1,8123,"![1553517637]($resource/1553517637.png)"]],[8123,8123],[8163,8163]]],[1553517682830,["28447@DESKTOP-BE7HQ26",[[1,8164,"\n"]],[8162,8162],[8163,8163]]],[1553517683413,["28447@DESKTOP-BE7HQ26",[[1,8165,"\n"]],[8163,8163],[8164,8164]]],[1553517739792,["28447@DESKTOP-BE7HQ26",[[1,8163,"1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接\n2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付\n3、TCP面向字节流，有流量拥塞控制。实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）\n4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 \n5、TCP首部开销20字节;UDP的首部开销小，只有8个字节 \n6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道\n--------------------- \n作者：筑梦悠然 \n来源：CSDN \n原文：https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78507826 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[8163,8163],[8632,8632]]],[1553517743597,["28447@DESKTOP-BE7HQ26",[[-1,8498,"--------------------- \n作者：筑梦悠然 \n来源：CSDN \n原文：https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78507826 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[8498,8632],[8498,8498]]],[1553517750102,["28447@DESKTOP-BE7HQ26",[[1,8163,"\n"]],[8162,8162],[8163,8163]]],[1553517752210,["28447@DESKTOP-BE7HQ26",[[-1,8163,"\n"]],[8163,8163],[8162,8162]]],[1553517753372,["28447@DESKTOP-BE7HQ26",[[1,8163,"\n"]],[8162,8162],[8163,8163]]],[1553517755935,["28447@DESKTOP-BE7HQ26",[[1,8164,"- "]],[8164,8164],[8166,8166]]],[1553517761976,["28447@DESKTOP-BE7HQ26",[[1,8214,"- "]],[8214,8214],[8216,8216]]],[1553517764513,["28447@DESKTOP-BE7HQ26",[[1,8285,"- "]],[8285,8285],[8287,8287]]],[1553517767109,["28447@DESKTOP-BE7HQ26",[[1,8395,"- "]],[8395,8395],[8397,8397]]],[1553517769878,["28447@DESKTOP-BE7HQ26",[[1,8442,"- "]],[8442,8442],[8444,8444]]],[1553517771626,["28447@DESKTOP-BE7HQ26",[[1,8476,"- "]],[8476,8476],[8478,8478]]],[1553517883133,["28447@DESKTOP-BE7HQ26",[[1,8511,"- \n"]],[8510,8510],[8513,8513]]],[1553517883372,["28447@DESKTOP-BE7HQ26",[[-1,8511,"- "]],[8513,8513],[8512,8512]]],[1553517885593,["28447@DESKTOP-BE7HQ26",[[1,8512,"wei"]],[8512,8512],[8515,8515]]],[1553517886447,["28447@DESKTOP-BE7HQ26",[[-1,8512,"wei"]],[8515,8515],[8512,8512]]],[1553517894107,["28447@DESKTOP-BE7HQ26",[[1,8512,"为什么可靠和不可靠："]],[8512,8512],[8522,8522]]],[1553517894275,["28447@DESKTOP-BE7HQ26",[[1,8525,"\n"]],[8522,8522],[8523,8523]]],[1553517897524,["28447@DESKTOP-BE7HQ26",[[1,8511,"****"]],[8511,8511],[8513,8513]]],[1553517899092,["28447@DESKTOP-BE7HQ26",[[-1,8516,"为什么可靠和不可靠："]],[8516,8526],[8516,8516]]],[1553517900172,["28447@DESKTOP-BE7HQ26",[[1,8513,"为什么可靠和不可靠："]],[8513,8513],[8523,8523]]],[1553517901312,["28447@DESKTOP-BE7HQ26",[[1,8511,"- \n"]],[8510,8510],[8513,8513]]],[1553517902307,["28447@DESKTOP-BE7HQ26",[[-1,8511,"- "]],[8513,8513],[8512,8512]]],[1553517903236,["28447@DESKTOP-BE7HQ26",[[1,8512,"\n"]],[8512,8512],[8513,8513]]],[1553517904279,["28447@DESKTOP-BE7HQ26",[[-1,8512,"\n"]],[8513,8513],[8512,8512]]],[1553517915521,["28447@DESKTOP-BE7HQ26",[[1,8527,"UDP只有一个socket接受缓冲区，没有socket发送缓冲区，即只要有数据就发，不管对方是否可以正确接受。而在对方的socket接受缓冲区满了之后，新来的数据报无法进入到socket接受缓冲区，此数据报就会被丢弃，udp是没有流量控制的，故UDP的数据传输是不可靠的。"]],[8527,8527],[8663,8663]]],[1553517918424,["28447@DESKTOP-BE7HQ26",[[1,8527,"\n"]],[8526,8526],[8527,8527]]],[1553517920997,["28447@DESKTOP-BE7HQ26",[[1,8527,"UDP:"]],[8527,8527],[8531,8531]]],[1553517923502,["28447@DESKTOP-BE7HQ26",[[1,8672,"\n"]],[8668,8668],[8669,8669]]],[1553517925402,["28447@DESKTOP-BE7HQ26",[[1,8669,"TCP："]],[8669,8669],[8673,8673]]],[1553517952092,["28447@DESKTOP-BE7HQ26",[[1,8674,"每个Tcp socket在内核中都有一个发送缓冲区和一个接受缓冲区。tcp协议要求对端在接受到tcp数据报之后，要对其序号进行ACK，只有当接受到一个tcp数据报的ACK之后，才可以把这个tcp数据报从socket的发送缓冲区清除，"]],[8674,8674],[8790,8790]]],[1553517953187,["28447@DESKTOP-BE7HQ26",[[-1,8789,"，"]],[8790,8790],[8789,8789]]],[1553517982379,["28447@DESKTOP-BE7HQ26",[[1,8789,"，另外tcp还有一个流量控制功能，tcp的socket接受缓冲区接受到网络上来的数据缓存起来后，如果应用程序一直没有读取，"]],[8789,8789],[8850,8850]]],[1553517997242,["28447@DESKTOP-BE7HQ26",[[1,8853,"\n"]],[8850,8850],[8851,8851]]],[1553518001593,["28447@DESKTOP-BE7HQ26",[[1,8852,"socket接受缓冲区满了之后，发生的动作是：通知对端TCP协议中的窗口关闭，这便是滑动窗口的实现，保证TCP socket接受缓冲区不会溢出，因为对方不允许发送超过所通知窗口大小的数据， 这就是TCP的流量控制，如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方TCP将丢弃它。这两点保证了tcp是可靠传输的。\n--------------------- \n作者：Joffer_Pong \n来源：CSDN \n原文：https://blog.csdn.net/Joffer_Pong/article/details/78824302 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[8852,8852],[9148,9148]]],[1553518003590,["28447@DESKTOP-BE7HQ26",[[-1,8851,"\n"]],[8852,8852],[8851,8851]]],[1553518006323,["28447@DESKTOP-BE7HQ26",[[1,8851,"\n"]],[8850,8850],[8851,8851]]],[1553518012465,["28447@DESKTOP-BE7HQ26",[[-1,9012,"--------------------- \n作者：Joffer_Pong \n来源：CSDN \n原文：https://blog.csdn.net/Joffer_Pong/article/details/78824302 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[9012,9148],[9012,9012]]],[1553520567009,["28447@DESKTOP-BE7HQ26",[[-1,9013,"\n"],[1,9014,"#"]],[9013,9013],[9014,9014]]],[1553520572516,["28447@DESKTOP-BE7HQ26",[[1,9014,"# MySQLsg"]],[9014,9014],[9023,9023]]],[1553520573250,["28447@DESKTOP-BE7HQ26",[[-1,9021,"sg"]],[9023,9023],[9021,9021]]],[1553520574479,["28447@DESKTOP-BE7HQ26",[[1,9021,"事故位于"]],[9021,9021],[9025,9025]]],[1553520575643,["28447@DESKTOP-BE7HQ26",[[-1,9021,"事故位于"]],[9025,9025],[9021,9021]]],[1553520580199,["28447@DESKTOP-BE7HQ26",[[1,9021,"事务时"]],[9021,9021],[9024,9024]]],[1553520581368,["28447@DESKTOP-BE7HQ26",[[-1,9023,"时"]],[9024,9024],[9023,9023]]],[1553520595132,["28447@DESKTOP-BE7HQ26",[[1,9023,"是什么？四大特性四大隔离级别"]],[9023,9023],[9037,9037]]],[1553520595815,["28447@DESKTOP-BE7HQ26",[[1,9037,"\n\n"]],[9037,9037],[9038,9038]]],[1553520596645,["28447@DESKTOP-BE7HQ26",[[-1,9038,"\n"]],[9038,9038],[9037,9037]]],[1553520597191,["28447@DESKTOP-BE7HQ26",[[1,9038,"\n"]],[9037,9037],[9038,9038]]],[1553520616199,["28447@DESKTOP-BE7HQ26",[[1,9031,"、"]],[9031,9031],[9032,9032]]],[1553520618187,["28447@DESKTOP-BE7HQ26",[[1,9040,"\n"]],[9039,9039],[9040,9040]]],[1553520619658,["28447@DESKTOP-BE7HQ26",[[-1,9040,"\n"],[1,9041,"*"]],[9040,9040],[9041,9041]]],[1553520619853,["28447@DESKTOP-BE7HQ26",[[1,9041,"***"]],[9041,9041],[9042,9042]]],[1553520625154,["28447@DESKTOP-BE7HQ26",[[1,9042,"四大特性："]],[9042,9042],[9047,9047]]],[1553520626142,["28447@DESKTOP-BE7HQ26",[[1,9049,"\n\n"]],[9049,9049],[9050,9050]]],[1553520627138,["28447@DESKTOP-BE7HQ26",[[-1,9050,"\n"],[1,9051,"-"]],[9050,9050],[9051,9051]]],[1553520643991,["28447@DESKTOP-BE7HQ26",[[1,9051," 原子性\n- 隔离性\n- 一致性\n- 稳定性"]],[9051,9051],[9073,9073]]],[1553520648400,["28447@DESKTOP-BE7HQ26",[[1,9055,"。"]],[9055,9055],[9056,9056]]],[1553520648963,["28447@DESKTOP-BE7HQ26",[[-1,9055,"。"]],[9056,9056],[9055,9055]]],[1553520657639,["28447@DESKTOP-BE7HQ26",[[1,9055,"：事务是一个不可分割的整体，事务开始的操作，要么全部执行，要么全部不执行"]],[9055,9055],[9091,9091]]],[1553520659369,["28447@DESKTOP-BE7HQ26",[[1,9097," "]],[9097,9097],[9098,9098]]],[1553520660721,["28447@DESKTOP-BE7HQ26",[[-1,9097," "]],[9098,9098],[9097,9097]]],[1553520661115,["28447@DESKTOP-BE7HQ26",[[1,9097,"："]],[9097,9097],[9098,9098]]],[1553520667027,["28447@DESKTOP-BE7HQ26",[[1,9098,"同一时间，只允许一个事务请求同一组数据。不同的事务彼此之间没有干扰。"]],[9098,9098],[9132,9132]]],[1553520671922,["28447@DESKTOP-BE7HQ26",[[1,9138,"：事务开始前和结束后，数据库的完整性约束没有被破坏 。"]],[9138,9138],[9165,9165]]],[1553520686870,["28447@DESKTOP-BE7HQ26",[[1,9171,"：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。\n- "]],[9171,9171],[9206,9206]]],[1553520687038,["28447@DESKTOP-BE7HQ26",[[-1,9204,"- "],[1,9206,"\n\n"]],[9206,9206],[9205,9205]]],[1553520687511,["28447@DESKTOP-BE7HQ26",[[-1,9205,"\n"],[1,9206,"*"]],[9205,9205],[9206,9206]]],[1553520687724,["28447@DESKTOP-BE7HQ26",[[1,9206,"***"]],[9206,9206],[9207,9207]]],[1553520692081,["28447@DESKTOP-BE7HQ26",[[1,9207,"四大级别"]],[9207,9207],[9211,9211]]],[1553520695764,["28447@DESKTOP-BE7HQ26",[[1,9209,"隔离"]],[9209,9209],[9211,9211]]],[1553520697092,["28447@DESKTOP-BE7HQ26",[[1,9215,"\n\n"]],[9215,9215],[9216,9216]]],[1553520698770,["28447@DESKTOP-BE7HQ26",[[-1,9216,"\n"],[1,9217,"-"]],[9216,9216],[9217,9217]]],[1553520717280,["28447@DESKTOP-BE7HQ26",[[1,9217," 1、read uncommitted。事务A对数据进行修改，但未提交。此时开启事务B，在事务B中能读到事务A中对数据库进行的未提交数据的修改。（这种方式也称为**脏读**）\n- 2、read committed。事务A对数据进行修改，但还未提交。此时开启事务B，在事务B中不能读到事务A中对数据库的修改。在事务B还没有关闭时，此时事务A提交对数据库的修改。这时候，我们在事务B中，可以查到事务A中对数据库的修改。这时存在一个问题，我们在同一个事务中，对数据库查询两次，但两次的结果是不一样的。（这种方式称为不可重复读。）\n--------------------- \n作者：没枕头我咋睡觉 \n来源：CSDN \n原文：https://blog.csdn.net/qq_41982304/article/details/81503238 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[9217,9217],[9611,9611]]],[1553520721247,["28447@DESKTOP-BE7HQ26",[[-1,9479,"--------------------- "],[-1,9502,"作者：没枕头我咋睡觉 \n来源：CSDN \n原文：https://blog.csdn.net/qq_41982304/article/details/81503238 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[9479,9611],[9479,9479]]],[1553520722811,["28447@DESKTOP-BE7HQ26",[[-1,9479,"\n"]],[9479,9479],[9478,9478]]],[1553520723264,["28447@DESKTOP-BE7HQ26",[[1,9479,"- \n"]],[9478,9478],[9481,9481]]],[1553520728994,["28447@DESKTOP-BE7HQ26",[[1,9481,"repetition read。事务A对数据进行修改，但未提交，此时开启事务B，在事务B中不能读到事务A对数据库的修改。在事务A提交对数据库修改时，此时在事务B中，仍不能读到事务A对数据库的修改。（这种方式称为可重复读）但此时有一个弊端，比如我们在事务A中对数据库增加一条数据，id 为 n ，这时候我们在事务B中查询数据，此时查不到id为n的数据。但当我们在事务B中增加id为n的数据时，系统会提示id为n的数据已经存在，我们添加失败。但此时此刻，我们在事务B中仍不能查询到id为n的数据。这种方式存在一个幻读的概念。举个例子，（系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后关闭事务发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。）\n--------------------- \n作者：没枕头我咋睡觉 \n来源：CSDN \n原文：https://blog.csdn.net/qq_41982304/article/details/81503238 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[9481,9481],[9987,9987]]],[1553520731858,["28447@DESKTOP-BE7HQ26",[[1,9481,"3、"]],[9481,9481],[9483,9483]]],[1553520736508,["28447@DESKTOP-BE7HQ26",[[-1,9857,"--------------------- \n作者：没枕头我咋睡觉 \n来源：CSDN \n原文：https://blog.csdn.net/qq_41982304/article/details/81503238 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[9857,9989],[9857,9857]]],[1553520738159,["28447@DESKTOP-BE7HQ26",[[-1,9857,"\n"],[1,9858,"-"]],[9857,9857],[9858,9858]]],[1553520738397,["28447@DESKTOP-BE7HQ26",[[1,9858," "]],[9858,9858],[9859,9859]]],[1553520738883,["28447@DESKTOP-BE7HQ26",[[-1,9858," "]],[9859,9859],[9858,9858]]],[1553520739098,["28447@DESKTOP-BE7HQ26",[[-1,9857,"-"],[1,9858,"\n"]],[9858,9858],[9857,9857]]],[1553520739887,["28447@DESKTOP-BE7HQ26",[[-1,9857,"\n"],[1,9858,"-"]],[9857,9857],[9858,9858]]],[1553520748007,["28447@DESKTOP-BE7HQ26",[[1,9858," 4、serializable。在开启事务A时，会产生锁表，此时别的事务会等待，等事务A结束时才会开启。"]],[9858,9858],[9910,9910]]],[1553520768669,["28447@DESKTOP-BE7HQ26",[[1,9236,"（）"]],[9236,9236],[9238,9238]]],[1553520776149,["28447@DESKTOP-BE7HQ26",[[1,9237,"读取未提交内容"]],[9237,9237],[9244,9244]]],[1553520783384,["28447@DESKTOP-BE7HQ26",[[1,9332,"（）"]],[9332,9332],[9334,9334]]],[1553520788967,["28447@DESKTOP-BE7HQ26",[[1,9333,"读取提交内容"]],[9333,9333],[9339,9339]]],[1553520792972,["28447@DESKTOP-BE7HQ26",[[1,9515,"（）"]],[9515,9515],[9517,9517]]],[1553520800932,["28447@DESKTOP-BE7HQ26",[[1,9516,"可重读"]],[9516,9516],[9519,9519]]],[1553520805259,["28447@DESKTOP-BE7HQ26",[[1,9895,"（）"]],[9895,9895],[9897,9897]]],[1553520810807,["28447@DESKTOP-BE7HQ26",[[1,9896,"可串行化"]],[9896,9896],[9900,9900]]],[1553520826776,["28447@DESKTOP-BE7HQ26",[[1,9040,"\n"]],[9038,9038],[9039,9039]]],[1553520826953,["28447@DESKTOP-BE7HQ26",[[1,9041,"\n"]],[9039,9039],[9040,9040]]],[1553520851590,["28447@DESKTOP-BE7HQ26",[[1,9040,"事务"]],[9040,9040],[9042,9042]]],[1553520852397,["28447@DESKTOP-BE7HQ26",[[-1,9040,"事务"]],[9042,9042],[9040,9040]]],[1553520853401,["28447@DESKTOP-BE7HQ26",[[1,9040,"****"]],[9040,9040],[9042,9042]]],[1553520854411,["28447@DESKTOP-BE7HQ26",[[1,9042,"事务"]],[9042,9042],[9044,9044]]],[1553520856358,["28447@DESKTOP-BE7HQ26",[[1,9046,"：事务是由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。程序和事务是两个不同的概念。一般而言：**一段程序中可能包含多个事务**。（**说白了就是几步的数据库操作而构成的逻辑执行单元**）"]],[9046,9046],[9159,9159]]],[1553520863330,["28447@DESKTOP-BE7HQ26",[[1,10059,"\n- "]],[10059,10059],[10062,10062]]],[1553520863531,["28447@DESKTOP-BE7HQ26",[[-1,10060,"- "],[1,10062,"\n\n"]],[10062,10062],[10061,10061]]],[1553520938026,["28447@DESKTOP-BE7HQ26",[[1,9640,"****"]],[9640,9640],[9642,9642]]],[1553520944783,["28447@DESKTOP-BE7HQ26",[[1,9642,"默认情况下"]],[9642,9642],[9647,9647]]],[1553520948501,["28447@DESKTOP-BE7HQ26",[[-1,9640,"**默认情况下**"]],[9640,9649],[9640,9640]]],[1553520952074,["28447@DESKTOP-BE7HQ26",[[1,9640,"：**默认情况下**"]],[9640,9640],[9650,9650]]],[1553520961120,["28447@DESKTOP-BE7HQ26",[[1,9648,"使用"]],[9648,9648],[9650,9650]]],[1553520974532,["28447@DESKTOP-BE7HQ26",[[-1,10073,"\n"],[1,10074,"【"]],[10073,10073],[10074,10074]]],[1553520975143,["28447@DESKTOP-BE7HQ26",[[-1,10073,"【"],[1,10074,"\n"]],[10074,10074],[10073,10073]]],[1553520975545,["28447@DESKTOP-BE7HQ26",[[-1,10073,"\n"],[1,10074,"["]],[10073,10073],[10074,10074]]],[1553520976768,["28447@DESKTOP-BE7HQ26",[[1,10074,"]("]],[10074,10074],[10076,10076]]],[1553520976815,["28447@DESKTOP-BE7HQ26",[[1,10076,"https://)"]],[10076,10076],[10076,10084]]],[1553520979445,["28447@DESKTOP-BE7HQ26",[[1,10084,"blog.csdn.net/l1394049664/article/details/81814090"]],[10076,10084],[10134,10134]]],[1553520982226,["28447@DESKTOP-BE7HQ26",[[1,10074,"shu"]],[10074,10074],[10077,10077]]],[1553520982959,["28447@DESKTOP-BE7HQ26",[[-1,10074,"shu"]],[10077,10077],[10074,10074]]],[1553520985591,["28447@DESKTOP-BE7HQ26",[[1,10074,"数据库"]],[10074,10074],[10077,10077]]],[1553520989906,["28447@DESKTOP-BE7HQ26",[[1,10074,"MySQL"]],[10074,10074],[10079,10079]]],[1553520994597,["28447@DESKTOP-BE7HQ26",[[1,10082,"知识点"]],[10082,10082],[10085,10085]]],[1553520999779,["28447@DESKTOP-BE7HQ26",[[-1,10079,"数据库知识点"]],[10085,10085],[10079,10079]]],[1553521001032,["28447@DESKTOP-BE7HQ26",[[1,10079,"数据库"]],[10079,10079],[10082,10082]]],[1553521010933,["28447@DESKTOP-BE7HQ26",[[1,10074,"# "],[1,10082,"事务的四大特性以及事务的隔离级别"]],[10074,10082],[10100,10100]]],[1553521013874,["28447@DESKTOP-BE7HQ26",[[-1,10073,"[#"]],[10073,10075],[10073,10073]]],[1553521015320,["28447@DESKTOP-BE7HQ26",[[1,10073,"["]],[10073,10073],[10074,10074]]],[1553521018975,["28447@DESKTOP-BE7HQ26",[[1,10160,"\n\n"]],[10160,10160],[10161,10161]]],[1553521019218,["28447@DESKTOP-BE7HQ26",[[1,10162,"\n"]],[10161,10161],[10162,10162]]],[1553521038494,["28447@DESKTOP-BE7HQ26",[[1,6384,"\n"]],[6383,6383],[6384,6384]]],[1553521038664,["28447@DESKTOP-BE7HQ26",[[1,6385,"\n"]],[6384,6384],[6385,6385]]],[1553521038827,["28447@DESKTOP-BE7HQ26",[[1,6386,"\n"]],[6385,6385],[6386,6386]]],[1553521044398,["28447@DESKTOP-BE7HQ26",[[1,6384,"### 有哪几种常用的线程池\\"]],[6384,6384],[6399,6399]]],[1553521045116,["28447@DESKTOP-BE7HQ26",[[-1,6398,"\\"]],[6399,6399],[6398,6398]]],[1553521045346,["28447@DESKTOP-BE7HQ26",[[1,6401,"\n"]],[6398,6398],[6399,6399]]],[1553524128152,["28447@DESKTOP-BE7HQ26",[[1,6402,"\n"]],[6398,6398],[6399,6399]]],[1553524128335,["28447@DESKTOP-BE7HQ26",[[1,6403,"\n"]],[6399,6399],[6400,6400]]],[1553524128504,["28447@DESKTOP-BE7HQ26",[[1,6404,"\n"]],[6400,6400],[6401,6401]]],[1553526898618,["28447@DESKTOP-BE7HQ26",[[1,6399,"xian"]],[6399,6399],[6403,6403]]],[1553526899436,["28447@DESKTOP-BE7HQ26",[[-1,6399,"xian"]],[6403,6403],[6399,6399]]],[1553526904842,["28447@DESKTOP-BE7HQ26",[[1,6399,"线程简介："]],[6399,6399],[6404,6404]]],[1553526905107,["28447@DESKTOP-BE7HQ26",[[1,6410,"\n"]],[6404,6404],[6405,6405]]],[1553526905589,["28447@DESKTOP-BE7HQ26",[[-1,6410,"\n"]],[6405,6405],[6404,6404]]],[1553526916756,["28447@DESKTOP-BE7HQ26",[[1,6404,"线程是操作系统能够进行运算调度的最小单位"]],[6404,6404],[6424,6424]]],[1553526917885,["28447@DESKTOP-BE7HQ26",[[1,6430,"\n"]],[6424,6424],[6425,6425]]],[1553526935439,["28447@DESKTOP-BE7HQ26",[[1,6424,"，**线程有就绪，阻塞，运行三种基本状态**"]],[6424,6424],[6446,6446]]],[1553526937794,["28447@DESKTOP-BE7HQ26",[[-1,6444,"**"]],[6446,6446],[6444,6444]]],[1553526938733,["28447@DESKTOP-BE7HQ26",[[-1,6425,"**"]],[6427,6427],[6425,6425]]],[1553526941276,["28447@DESKTOP-BE7HQ26",[[1,6442,"。"]],[6442,6442],[6443,6443]]],[1553526942154,["28447@DESKTOP-BE7HQ26",[[1,6450,"\n"]],[6443,6443],[6444,6444]]],[1553526971067,["28447@DESKTOP-BE7HQ26",[[1,6445,"xian"]],[6445,6445],[6449,6449]]],[1553526972039,["28447@DESKTOP-BE7HQ26",[[-1,6445,"xian"]],[6449,6449],[6445,6445]]],[1553526988641,["28447@DESKTOP-BE7HQ26",[[1,6445,"线程池概念："]],[6445,6445],[6451,6451]]],[1553527102967,["28447@DESKTOP-BE7HQ26",[[1,6451,"线程池是一种多线程处理形式，处理过程中将任务添加队列，然后在创建线程后自动启动这些任务，每个线程都使用默认的堆栈大小，以默认的优先级运行，并处在多线程单元中，如果某个线程在托管代码中空闲，则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后辅助线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才能启动。"],[1,6452,"--------------------- \n作者：真·深红骑士 \n来源：CSDN \n原文：https://blog.csdn.net/qq_33453910/article/details/81413285 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[6451,6452],[6789,6789]]],[1553527105961,["28447@DESKTOP-BE7HQ26",[[-1,6658,"--------------------- \n作者：真·深红骑士 \n来源：CSDN \n原文：https://blog.csdn.net/qq_33453910/article/details/81413285 \n版权声明：本文为博主原创文章，转载请附上博文链接！\n"]],[6658,6790],[6658,6658]]],[1553527112420,["28447@DESKTOP-BE7HQ26",[[1,6662,"\n"]],[6657,6657],[6658,6658]]],[1553527112654,["28447@DESKTOP-BE7HQ26",[[1,6663,"\n"]],[6658,6658],[6659,6659]]],[1553527131155,["28447@DESKTOP-BE7HQ26",[[1,6659,"java里面的线程池的顶级接口是**Executor**，Executor并不是一个线程池，而只是一个执行线程的工具，而真正的线程池是**ExecutorService**。"]],[6659,6659],[6746,6746]]],[1553527133045,["28447@DESKTOP-BE7HQ26",[[1,6751,"\n"]],[6747,6747],[6748,6748]]],[1553527142488,["28447@DESKTOP-BE7HQ26",[[1,6748,"java中的有哪些线程池？\n\n1.newCachedThreadPool创建一个可缓存线程池程\n\n2.newFixedThreadPool 创建一个定长线程池\n\n3.newScheduledThreadPool 创建一个定长线程池\n\n4.newSingleThreadExecutor 创建一个单线程化的线程池\n--------------------- \n作者：真·深红骑士 \n来源：CSDN \n原文：https://blog.csdn.net/qq_33453910/article/details/81413285 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[6748,6748],[7035,7035]]],[1553527145742,["28447@DESKTOP-BE7HQ26",[[-1,6904,"--------------------- \n作者：真·深红骑士 \n来源：CSDN \n原文：https://blog.csdn.net/qq_33453910/article/details/81413285 \n版权声明：本文为博主原创文章，转载请附上博文链接！\n"]],[6904,7036],[6904,6904]]],[1553527149272,["28447@DESKTOP-BE7HQ26",[[1,6763,"- "]],[6763,6763],[6765,6765]]],[1553527151915,["28447@DESKTOP-BE7HQ26",[[-1,6798,"\n"]],[6799,6799],[6798,6798]]],[1553527152922,["28447@DESKTOP-BE7HQ26",[[1,6798,"- "]],[6798,6798],[6800,6800]]],[1553527155215,["28447@DESKTOP-BE7HQ26",[[-1,6831,"\n"]],[6832,6832],[6831,6831]]],[1553527156690,["28447@DESKTOP-BE7HQ26",[[1,6831,"- "]],[6831,6831],[6833,6833]]],[1553527158864,["28447@DESKTOP-BE7HQ26",[[-1,6868,"\n"]],[6869,6869],[6868,6868]]],[1553527160083,["28447@DESKTOP-BE7HQ26",[[1,6868,"- "]],[6868,6868],[6870,6870]]],[1553527162395,["28447@DESKTOP-BE7HQ26",[[-1,6762,"\n"]],[6762,6762],[6761,6761]]],[1553527171388,["28447@DESKTOP-BE7HQ26",[[1,6748,"****"]],[6748,6748],[6750,6750]]],[1553527174769,["28447@DESKTOP-BE7HQ26",[[-1,6752,"java中的有哪些线程池？"]],[6752,6765],[6752,6752]]],[1553527175742,["28447@DESKTOP-BE7HQ26",[[1,6750,"java中的有哪些线程池？"]],[6750,6750],[6763,6763]]],[1553528453922,["28447@DESKTOP-BE7HQ26",[[1,6915,"\n"]],[6912,6912],[6913,6913]]],[1553528454211,["28447@DESKTOP-BE7HQ26",[[1,6913,"1.newCachedThreadPool,是一种线程数量不定的线程池，并且其最大线程数为Integer.MAX_VALUE，这个数是很大的，一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。但是线程池中的空闲线程都有超时限制，这个超时时长是60秒，超过60秒闲置线程就会被回收。调用execute将重用以前构造的线程(如果线程可用)。这类线程池比较适合执行大量的耗时较少的任务，当整个线程池都处于闲置状态时，线程池中的线程都会超时被停止。\n--------------------- \n作者：真·深红骑士 \n来源：CSDN \n原文：https://blog.csdn.net/qq_33453910/article/details/81413285 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[6913,6913],[7285,7285]]],[1553528458036,["28447@DESKTOP-BE7HQ26",[[-1,7154,"--------------------- \n作者：真·深红骑士 \n来源：CSDN \n原文：https://blog.csdn.net/qq_33453910/article/details/81413285 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[7154,7285],[7154,7154]]],[1553528458464,["28447@DESKTOP-BE7HQ26",[[1,7157,"\n"]],[7154,7154],[7155,7155]]],[1553528459073,["28447@DESKTOP-BE7HQ26",[[1,7155,"2、"]],[7155,7155],[7157,7157]]],[1553528462581,["28447@DESKTOP-BE7HQ26",[[-1,6914,"."]],[6915,6915],[6914,6914]]],[1553528462852,["28447@DESKTOP-BE7HQ26",[[1,6914,"、"]],[6914,6914],[6915,6915]]],[1553528471886,["28447@DESKTOP-BE7HQ26",[[1,7157,"newFixedThreadPool 创建一个指定工作线程数量的线程池，每当提交一个任务就创建一个工作线程，当线程 处于空闲状态时，它们并不会被回收，除非线程池被关闭了，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列（没有大小限制）中。由于newFixedThreadPool只有核心线程并且这些核心线程不会被回收，这样它更加快速底相应外界的请求。\n--------------------- \n作者：真·深红骑士 \n来源：CSDN \n原文：https://blog.csdn.net/qq_33453910/article/details/81413285 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[7157,7157],[7473,7473]]],[1553528475462,["28447@DESKTOP-BE7HQ26",[[-1,7342,"--------------------- \n作者：真·深红骑士 \n来源：CSDN \n原文：https://blog.csdn.net/qq_33453910/article/details/81413285 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[7342,7473],[7342,7342]]],[1553528476881,["28447@DESKTOP-BE7HQ26",[[1,7345,"\n"]],[7342,7342],[7343,7343]]],[1553528477339,["28447@DESKTOP-BE7HQ26",[[1,7343,"3、"]],[7343,7343],[7345,7345]]],[1553528483434,["28447@DESKTOP-BE7HQ26",[[-1,7343,"3、"],[1,7345,"**3.newScheduledThreadPool **创建一个线程池，它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收，它可安排给定延迟后运行命令或者定期地执行。这类线程池主要用于执行定时任务和具有固定周期的重复任务。"]],[7343,7345],[7474,7474]]],[1553528485528,["28447@DESKTOP-BE7HQ26",[[1,7477,"\n"]],[7474,7474],[7475,7475]]],[1553528486435,["28447@DESKTOP-BE7HQ26",[[1,7478,"\n"]],[7475,7475],[7476,7476]]],[1553528493370,["28447@DESKTOP-BE7HQ26",[[1,7476,"**4.newSingleThreadExecutor**这类线程池内部只有一个核心线程，以无界队列方式来执行该线程，这使得这些任务之间不需要处理线程同步的问题，它确保所有的任务都在同一个线程中按顺序中执行，并且可以在任意给定的时间不会有多个线程是活动的。"]],[7476,7476],[7604,7604]]],[1553528511946,["28447@DESKTOP-BE7HQ26",[[-1,7156,"、"],[1,7157,"."],[1,7341,"\n--------------------- \n作者：真·深红骑士 \n来源：CSDN \n原文：https://blog.csdn.net/qq_33453910/article/details/81413285 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[7155,7341],[7473,7473]]],[1553528526696,["28447@DESKTOP-BE7HQ26",[[-1,7341,"--------------------- \n作者：真·深红骑士 \n来源：CSDN \n原文：https://blog.csdn.net/qq_33453910/article/details/81413285 \n版权声明：本文为博主原创文章，转载请附上博文链接！。"]],[7155,7473],[7341,7341]]],[1553528527246,["28447@DESKTOP-BE7HQ26",[[-1,7342,"\n"]],[7341,7341],[7340,7340]]],[1553528528427,["28447@DESKTOP-BE7HQ26",[[1,7340,"。"],[-1,7368," "],[1,7369," "]],[7340,7340],[7341,7341]]],[1553528532588,["28447@DESKTOP-BE7HQ26",[[1,7155,"****"]],[7155,7155],[7157,7157]]],[1553528535898,["28447@DESKTOP-BE7HQ26",[[-1,7159,"2.newFixedThreadPool"]],[7159,7179],[7159,7159]]],[1553528536974,["28447@DESKTOP-BE7HQ26",[[1,7157,"2.newFixedThreadPool"]],[7157,7157],[7177,7177]]],[1553528540544,["28447@DESKTOP-BE7HQ26",[[1,6913,"****"]],[6913,6913],[6915,6915]]],[1553528543840,["28447@DESKTOP-BE7HQ26",[[-1,6917,"1、newCachedThreadPool,"]],[6917,6939],[6917,6917]]],[1553528544803,["28447@DESKTOP-BE7HQ26",[[1,6915,"1、newCachedThreadPool,"]],[6915,6915],[6937,6937]]],[1553528546378,["28447@DESKTOP-BE7HQ26",[[-1,6936,","]],[6937,6937],[6936,6936]]],[1553528592563,[null,[[-1,7348,"。"],[1,7349,"\n"]],[7348,7348],[7350,7350]]],[1553528592563,[null,[[1,7348,"。"],[-1,7348,"\n"]],[7350,7350],[7348,7348]]],[1553528567077,["28447@DESKTOP-BE7HQ26",[[1,6399,"\n"]],[6398,6398],[6399,6399]]],[1553528568255,["28447@DESKTOP-BE7HQ26",[[1,6399,"[]"]],[6399,6399],[6401,6401]]],[1553528572089,["28447@DESKTOP-BE7HQ26",[[-1,6399,"[]"]],[6400,6400],[6399,6399]]],[1553528581431,["28447@DESKTOP-BE7HQ26",[[1,7613,"【】"]],[7613,7613],[7615,7615]]],[1553528582470,["28447@DESKTOP-BE7HQ26",[[-1,7613,"【】"]],[7615,7615],[7613,7613]]],[1553528585272,["28447@DESKTOP-BE7HQ26",[[1,7613,"[]("]],[7613,7613],[7616,7616]]],[1553528585333,["28447@DESKTOP-BE7HQ26",[[1,7616,"https://)"]],[7616,7616],[7616,7624]]],[1553528586545,["28447@DESKTOP-BE7HQ26",[[1,7624,"blog.csdn.net/qq_33453910/article/details/81413285"]],[7616,7624],[7674,7674]]],[1553528591811,["28447@DESKTOP-BE7HQ26",[[1,7614,"# java中的线程池有哪些，分别有什么作用？"]],[7614,7614],[7637,7637]]],[1553528594721,[null,[[-1,7349,"。"],[1,7350,"\n"]],[7349,7349],[7351,7351]]],[1553528594721,[null,[[1,7349,"。"],[-1,7349,"\n"]],[7351,7351],[7349,7349]]],[1553528593857,["28447@DESKTOP-BE7HQ26",[[-1,7614,"#"]],[7615,7615],[7614,7614]]],[1553528834726,[null,[[-1,7349,"。"],[1,7350,"\n"]],[7349,7349],[7351,7351]]],[1553528834726,[null,[[1,7349,"。"],[-1,7349,"\n"]],[7351,7351],[7349,7349]]],[1553528833195,["28447@DESKTOP-BE7HQ26",[[1,7699,"\n"]],[7698,7698],[7699,7699]]],[1553528833386,["28447@DESKTOP-BE7HQ26",[[1,7700,"\n"]],[7699,7699],[7700,7700]]],[1553528833574,["28447@DESKTOP-BE7HQ26",[[1,7701,"\n"]],[7700,7700],[7701,7701]]],[1553528852014,[null,[[-1,7349,"。"],[1,7350,"\n"]],[7349,7349],[7351,7351]]],[1553528852014,[null,[[1,7349,"。"],[-1,7349,"\n"]],[7351,7351],[7349,7349]]],[1553528835803,["28447@DESKTOP-BE7HQ26",[[1,7699,"##3"]],[7699,7699],[7702,7702]]],[1553528836440,["28447@DESKTOP-BE7HQ26",[[-1,7701,"3"]],[7702,7702],[7701,7701]]],[1553528837456,["28447@DESKTOP-BE7HQ26",[[1,7701,"￥"]],[7701,7701],[7702,7702]]],[1553528839781,["28447@DESKTOP-BE7HQ26",[[-1,7701,"￥"]],[7702,7702],[7701,7701]]],[1553528849123,["28447@DESKTOP-BE7HQ26",[[1,7701,"# 什么情况下使用Runnable和Thread创建线程，Runnable和Callable的区别"]],[7701,7701],[7750,7750]]],[1553528850965,["28447@DESKTOP-BE7HQ26",[[1,7753,"\n"]],[7750,7750],[7751,7751]]],[1553529096610,[null,[[-1,7349,"。"],[1,7350,"\n"]],[7349,7349],[7351,7351]]],[1553529096610,[null,[[1,7349,"。"],[-1,7349,"\n"]],[7351,7351],[7349,7349]]],[1553529095306,["28447@DESKTOP-BE7HQ26",[[-1,5829,"z1ZyCTibgvW1H5TXzXDlQnuuNiaK0ce42zv6hz0L3rt2icZePaAmT4Dd"],[1,5885,"nNGzjcWYy3ylL7s1Bq2UKicU5mYG8SHsuIFTOf2PMe2FstpM2gMeQb"]],[5733,5891],[5889,5889]]],[1553529156606,[null,[[-1,7347,"。"],[1,7348,"\n"]],[7347,7347],[7349,7349]]],[1553529156606,[null,[[1,7347,"。"],[-1,7347,"\n"]],[7349,7349],[7347,7347]]],[1553529100270,["28447@DESKTOP-BE7HQ26",[[-1,5733,"![640]("],[-1,5888,")"]],[5733,5889],[5881,5881]]],[1553529102802,["28447@DESKTOP-BE7HQ26",[[1,5733,"![640]("],[1,5881,")"]],[5881,5881],[5733,5889]]],[1553529105409,["28447@DESKTOP-BE7HQ26",[[-1,5733,"![640]("],[-1,5888,")\n"]],[5733,5890],[5881,5881]]],[1553529107061,["28447@DESKTOP-BE7HQ26",[[1,5733,"![640]("],[1,5881,")\n"]],[5881,5881],[5733,5890]]],[1553529305049,[null,[[-1,7347,"。"],[1,7348,"\n"]],[7347,7347],[7349,7349]]],[1553529305049,[null,[[1,7347,"。"],[-1,7347,"\n"]],[7349,7349],[7347,7347]]],[1553529288007,["28447@DESKTOP-BE7HQ26",[[1,7750,"【"]],[7750,7750],[7751,7751]]],[1553529288766,["28447@DESKTOP-BE7HQ26",[[-1,7750,"【"]],[7751,7751],[7750,7750]]],[1553529289355,["28447@DESKTOP-BE7HQ26",[[1,7750,"[]"]],[7750,7750],[7752,7752]]],[1553529290143,["28447@DESKTOP-BE7HQ26",[[1,7751,"# Callable,Runnable比较及用法以及创建线程的4种方法"]],[7751,7751],[7786,7786]]],[1553529294323,["28447@DESKTOP-BE7HQ26",[[1,7787,"("]],[7787,7787],[7788,7788]]],[1553529294377,["28447@DESKTOP-BE7HQ26",[[1,7788,"https://)"]],[7788,7788],[7788,7796]]],[1553529301873,["28447@DESKTOP-BE7HQ26",[[-1,7788,"https://"]],[7795,7795],[7788,7788]]],[1553529302212,["28447@DESKTOP-BE7HQ26",[[1,7788,"https://blog.csdn.net/xyw591238/article/details/51900325"]],[7788,7788],[7844,7844]]],[1553529304409,["28447@DESKTOP-BE7HQ26",[[-1,7751,"# "]],[7753,7753],[7751,7751]]]],null,"28447@DESKTOP-BE7HQ26"],["eea151cd-63d0-466f-91b9-a3a134fdec34",1553571943018,"# Java知识点\n\n\n##  集合、线程\n\n\n\n### **HashTable实现原理，HashMap实现原理，ConcurrentHashMap实现原理**\n[1、jdk1.7 HashMap原理](https://www.cnblogs.com/chengxiao/p/6059914.html)\n[ 2、Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析](http://www.importnew.com/28263.html)\n[ 3、ConcurrentHashMap在jdk1.8中的改进](https://www.cnblogs.com/everSeeker/p/5601861.html)\n\n**jdk1.8 HashMap结构图：**\n![2](https://javadoop.com/blogimages/map/2.png)\n\n**jdk1.8实现方式与jdk1.7不同：**\n- HashMap和ConcurrentHashMap都加入了**红黑树**，对于个数超过8个（默认值）的列表，jdk1.8采用红黑树的结构，查询的时间复杂度可以降到O(logN)\n- ConcurrentHashMap：取消segments字段，直接采用transient volatile HashEntry<K,V>[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率\n\n**以下为jdk1.7实现方式**\n**HashTable**\n*   底层数组+单向链表实现，无论key还是value都**不能为null**，线程**安全**，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化\n*   初始size为**11**，扩容：newsize = olesize*2+1\n*   计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length\n\n**HashMap**\n*   底层数组+单向链表实现，可**以存储null键和null值**，线程**不安全**\n*   初始size为**16**，扩容：newsize = oldsize*2，size一定为2的n次幂\n*   扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入\n*   插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）\n*   当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀\n*   计算index方法：index = hash & (tab.length – 1)\n\nHashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。\n```java\n//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。\ntransient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;\n```\nHashMap和Hashtable都是用hash算法来决定其元素的存储，因此HashMap和Hashtable的hash表包含如下属性：\n\n*   容量（capacity）：hash表中桶的数量\n*   初始化容量（initial capacity）：创建hash表时桶的数量，HashMap允许在构造器中指定初始化容量\n*   尺寸（size）：当前hash表中记录的数量\n*   负载因子（load factor）：负载因子等于“size/capacity”。负载因子为0，表示空的hash表，0.5表示半满的散列表，依此类推。轻负载的散列表具有冲突少、适宜插入与查询的特点（但是使用Iterator迭代元素时比较慢）\n\n除此之外，hash表里还有一个“负载极限”，“负载极限”是一个0～1的数值，“负载极限”决定了hash表的最大填满程度。当hash表中的负载因子达到指定的“负载极限”时，hash表会自动成倍地增加容量（桶的数量），并将原有的对象重新分配，放入新的桶内，这称为rehashing。\n\n**“负载极限”的默认值（0.75）是时间和空间成本上的一种折中**\n\n*   较高的“负载极限”可以降低hash表所占用的内存空间，但会增加查询数据的时间开销，而查询是最频繁的操作（HashMap的get()与put()方法都要用到查询）\n*   较低的“负载极限”会提高查询数据的性能，但会增加hash表所占用的内存开销\n\n![](https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png)\n\n\n**ConcurrentHashMap**\n*   底层采用分段的数组+单向链表实现，线程**安全**\n*   通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)\n*   Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术\n*   有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁\n*   扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容\n\n\nConcurrentHashMap比HashMap多出了一个类Segment，而Segment是一个可重入锁。\n\nConcurrentHashMap是使用了锁分段技术来保证线程安全的。\n\n**锁分段技术**：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 \n\nConcurrentHashMap提供了与Hashtable和SynchronizedMap不同的锁机制。**Hashtable中采用的锁机制是一次锁住整个hash表**，从而在同一时刻只能由一个线程对其进行操作；而**ConcurrentHashMap中则是一次锁住一个桶**。\n\nConcurrentHashMap默认将hash表分为16个桶，诸如get、put、remove等常用操作只锁住当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。\n\n\n### **HashMap在高并发环境下会产生的问题**\n 问题：\n - HashMap死循环，照成CPU100%负载\n - 触发fail-fast\n\n**1、HashMap死循环的原因**\n\nHashMap进行存储时，如果size超过（当前最大容量*负载因子）时候会发生resize，首先看一下resize源代码：\n```java\nvoid resize(int newCapacity) { \n  Entry[] oldTable = table; \n  int oldCapacity =  oldTable.length; \n  if (oldCapacity == MAXIMUM_CAPACITY) { \n      threshold = Integer.MAX_VALUE; \n      return; \n   } \n  Entry[] newTable = new Entry[newCapacity]; \n  // transfer方法是真正执行rehash的操作，容易在高并发时发生问题 \n  transfer(newTable); \n  table = newTable; \n  threshold = (int)(newCapacity * loadFactor); \n}\n```\n**而这段代码中又调用了transfer()方法，而这个方法实现的机制就是将每个链表转化到新链表，并且链表中的位置发生反转，而这在多线程情况下是很容易造成链表回路，从而发生死循环**，我们看一下他的源代码:\n```java\nvoid tansfer(Entry[] newTable) {\n\t   Entry[] src = table;\n\t   int newCapacity = newTable.length;\n\t   for (int j = 0; j < src.length; j++) {\n\t       Entry<K,V> e = src[j];\n\t       if (e != null) {\n\t           src[j] = null;\n\t           do {\n\t               Entry<K,V> next = e.next;\n\t               int i = indexFor(e.hash, newCapacity);\n\t               e.next = newTable[i];\n\t               newTable[i] = e;\n\t               e = next;\n\t           } while (e != null);\n\t       }\n\t   }\n\t}\n```\n**2、触发fail-fast：**\n**一个线程利用迭代器迭代时，另一个线程做插入删除操作，造成迭代的fast-fail。**\n```java\npublic class TestFailFast {\n    \n    private static final String USER_NAME_PREFIX = \"User-\";\n    // Key: User Name, Value: User Age\n    private static Map<String, Integer> userMap = new HashMap<>();\n    \n    // ThreadA 用于向HashMap添加元素\n    static class ThreadA implements Runnable {\n        @Override\n        public void run() {\n            System.out.println(\"ThreadA starts to add user.\");\n            for (int i = 1; i < 100000; i++) {\n                userMap.put(USER_NAME_PREFIX+i, i%100);\n            }\n            System.out.println(\"ThreadA done.\");\n        }\n    }\n    \n    // ThreadB 用于遍历HashMap中元素输出\n    static class ThreadB implements Runnable {\n        @Override\n        public void run() {\n            System.out.println(\"ThreadB starts to iterate.\");\n            for (Map.Entry<String, Integer> user : userMap.entrySet()) {\n                System.out.println(\"UserName=\" + user.getKey()\n                    + \", UserAge=\" + user.getValue());\n            }\n            System.out.println(\"ThreadB done.\");\n        }\n    }\n    \n    public static void main(String[] args) throws InterruptedException {\n        Thread threadA = new Thread(new ThreadA());\n        Thread threadB = new Thread(new ThreadB());\n    \n        threadA.start();\n        threadB.start();\n  \n        threadA.join();\n        threadB.join();\n        System.exit(0);\n    }\n}\n```\n运行结果：抛出ConcurrentModificationException\n\n\n\n\n\n\n\n\n\n\n\n\n### **红黑树，为什么允许局部不平衡**\n\n\n\n\n\n### **什么是一致性Hash算法**\n\n原因：\n应用场景：redis缓存假设使用普通hash取模的方式。在增加节点或减少节点时，映射规则将被改变，当应用无法从缓存中获取数据，则会想后端数据库请求数据\n\n![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbhiae1AfNYAibdp7ib2wTZTrpnNGzjcWYy3ylL7s1Bq2UKicU5mYG8SHsuIFTOf2PMe2FstpM2gMeQbw/640)\n\n- hash值是个整数非负，非负整数的值范围做成一个圆环`Hash环`（0——2^32-1）；\n- 对集群的节点的某个属性（比如节点名）求hash值，放在环上；\n- 对数据key求hash值，也放在环上，按顺时针方向找到离它最近的节点，放在它上面。\n\n`附` 如何避免Hash环的数据倾斜？\n\n引入`虚拟节点`，例如将每台服务器就算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点\n![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbhiae1AfNYAibdp7ib2wTZTrpnNGzjcWYy3ylL7s1Bq2UKicU5mYG8SHsuIFTOf2PMe2FstpM2gMeQbw/640)\n\n[参考文章](https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368)\n\n### 有哪几种常用的线程池\n\n线程简介：线程是操作系统能够进行运算调度的最小单位，线程有就绪，阻塞，运行三种基本状态。\n\n线程池概念：线程池是一种多线程处理形式，处理过程中将任务添加队列，然后在创建线程后自动启动这些任务，每个线程都使用默认的堆栈大小，以默认的优先级运行，并处在多线程单元中，如果某个线程在托管代码中空闲，则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后辅助线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才能启动。\n\njava里面的线程池的顶级接口是**Executor**，Executor并不是一个线程池，而只是一个执行线程的工具，而真正的线程池是**ExecutorService**。\n\n**java中的有哪些线程池？**\n- 1.newCachedThreadPool创建一个可缓存线程池程\n- 2.newFixedThreadPool 创建一个定长线程池\n- 3.newScheduledThreadPool 创建一个定长线程池\n- 4.newSingleThreadExecutor 创建一个单线程化的线程池\n\n**1、newCachedThreadPool**是一种线程数量不定的线程池，并且其最大线程数为Integer.MAX_VALUE，这个数是很大的，一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。但是线程池中的空闲线程都有超时限制，这个超时时长是60秒，超过60秒闲置线程就会被回收。调用execute将重用以前构造的线程(如果线程可用)。这类线程池比较适合执行大量的耗时较少的任务，当整个线程池都处于闲置状态时，线程池中的线程都会超时被停止。\n\n**2.newFixedThreadPool** 创建一个指定工作线程数量的线程池，每当提交一个任务就创建一个工作线程，当线程 处于空闲状态时，它们并不会被回收，除非线程池被关闭了，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列（没有大小限制）中。由于newFixedThreadPool只有核心线程并且这些核心线程不会被回收，这样它更加快速底相应外界的请求。\n\n**3.newScheduledThreadPool **创建一个线程池，它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收，它可安排给定延迟后运行命令或者定期地执行。这类线程池主要用于执行定时任务和具有固定周期的重复任务。\n\n**4.newSingleThreadExecutor**这类线程池内部只有一个核心线程，以无界队列方式来执行该线程，这使得这些任务之间不需要处理线程同步的问题，它确保所有的任务都在同一个线程中按顺序中执行，并且可以在任意给定的时间不会有多个线程是活动的。\n[ java中的线程池有哪些，分别有什么作用？](https://blog.csdn.net/qq_33453910/article/details/81413285)\n\n### 什么情况下使用Runnable和Thread创建线程，Runnable和Callable的区别\n\n[Callable,Runnable比较及用法以及创建线程的4种方法](https://blog.csdn.net/xyw591238/article/details/51900325)\n\n## **网络**\n\n### **TCP三次握手**\n  - 第一次握手：建立连接时，客户端发送syn（Synchronize Sequence Numbers：同步序列编号）包（sny=1）到服务器，并进入SYN_SEND（请求连接）状态，等待服务器确认;\n  - 第二次握手：服务器接收到syn包，必须确认客户的syn（ack=j+1）（ack：确认字符，表示发来的数据已确认接收无误），同时自己也发送一个syn包（sny=k），既ack+syn包，此时服务器进入SYN_RECV（发送了ACK时的状态）状态。\n  - 第三次握手：客户端收到服务端发送的syn+ack包，向服务端发送确认包ack（sny+1既ack=k+1），此包发送完毕，客户端与服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n  \n![TCP三次握手图](https://img-blog.csdn.net/20180830135313575?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nemhhb3lhbmcxMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n### **TCP四次挥手**\n\n  - 第一次挥手：TCP客户端发送一个FIN+ACK+SEQ，用来传输关闭客户端到服务端的数据。进入FIN_WAIT1状态。\n  - 第二次挥手：服务端收到FIN，被动发送一个ACK（SEQ+1）,进入CLOSE_WAIT状态，客户端收到服务端发送的ACK，进入FIN_WAIT2状态。\n  - 第三次挥手：服务器关闭客户端连接，发送一个FIN给+ACK+SEQ客户端。进入LAST_ACK状态。\n  - 第四次挥手：客户端发送ACK（ACK=SQE序号+1）报文确认，客户端进入TIME_WAIT状态，服务端收到ACK进入CLOSE状态。\n  \n![](https://img-blog.csdn.net/20180830142208139?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nemhhb3lhbmcxMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n### **说说几种HTTP响应码**\n      ☆ 200 OK：表示客户端请求成功。\n      ☆ 400 Bad Request 语义有误，不能被当前服务器理解。\n      ☆ 401 Unauthorized 当前请求需要用户验证。\n      ☆ 403 Forbidden 服务器收到消息，但是拒绝提供服务。\n      ☆ 404 Not Found 请求资源不存在。\n      ☆ 408 Request Timeout 请求超时，客户端没有在服务器预备等待的时间内完成发送。\n      ☆ 500 Internal Server Error 服务器发生不可预期的错误。\n      ☆ 503 Server Unavailable 由于临时的服务器维护或过载，服务器当前不能处理请求，此状况知识临时的，可恢复\n\n### **当你用浏览器打开一个链接时，计算机做了哪些步骤**\n  - 1、解析域名\n  - 2、发次TCP的3次握手\n  - 3、建立TCP请求后发起HTTP请求\n  - 4、服务器相应的HTTP请求\n  - 5、浏览器得到HTML代码，进行解析和处理JSON数据，并请求HTML代码中的静态资源（JS、CSS、图片等）\n  - 6、浏览器对页面进行渲染 \n\n[网络面试知识点1](https://blog.csdn.net/zhengzhaoyang122/article/details/82184072)\n[网络面试知识点2](https://www.cnblogs.com/huajiezh/p/7492416.html)\n\n### **TCP，UDP区别，为什么可靠和不可靠**\n\n![1553517637]($resource/1553517637.png)\n\n- 1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接\n- 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付\n- 3、TCP面向字节流，有流量拥塞控制。实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）\n- 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 \n- 5、TCP首部开销20字节;UDP的首部开销小，只有8个字节 \n- 6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道\n\n**为什么可靠和不可靠：**\nUDP:\nUDP只有一个socket接受缓冲区，没有socket发送缓冲区，即只要有数据就发，不管对方是否可以正确接受。而在对方的socket接受缓冲区满了之后，新来的数据报无法进入到socket接受缓冲区，此数据报就会被丢弃，udp是没有流量控制的，故UDP的数据传输是不可靠的。\nTCP：\n每个Tcp socket在内核中都有一个发送缓冲区和一个接受缓冲区。tcp协议要求对端在接受到tcp数据报之后，要对其序号进行ACK，只有当接受到一个tcp数据报的ACK之后，才可以把这个tcp数据报从socket的发送缓冲区清除，另外tcp还有一个流量控制功能，tcp的socket接受缓冲区接受到网络上来的数据缓存起来后，如果应用程序一直没有读取，\n\nsocket接受缓冲区满了之后，发生的动作是：通知对端TCP协议中的窗口关闭，这便是滑动窗口的实现，保证TCP socket接受缓冲区不会溢出，因为对方不允许发送超过所通知窗口大小的数据， 这就是TCP的流量控制，如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方TCP将丢弃它。这两点保证了tcp是可靠传输的。\n\n## MySQL事务是什么？四大特性、四大隔离级别\n\n**事务**：事务是由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。程序和事务是两个不同的概念。一般而言：**一段程序中可能包含多个事务**。（**说白了就是几步的数据库操作而构成的逻辑执行单元**）\n\n**四大特性：**\n- 原子性：事务是一个不可分割的整体，事务开始的操作，要么全部执行，要么全部不执行\n- 隔离性：同一时间，只允许一个事务请求同一组数据。不同的事务彼此之间没有干扰。\n- 一致性：事务开始前和结束后，数据库的完整性约束没有被破坏 。\n- 稳定性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。\n\n**四大隔离级别**\n- 1、read uncommitted（读取未提交内容）。事务A对数据进行修改，但未提交。此时开启事务B，在事务B中能读到事务A中对数据库进行的未提交数据的修改。（这种方式也称为**脏读**）\n- 2、read committed（读取提交内容）。事务A对数据进行修改，但还未提交。此时开启事务B，在事务B中不能读到事务A中对数据库的修改。在事务B还没有关闭时，此时事务A提交对数据库的修改。这时候，我们在事务B中，可以查到事务A中对数据库的修改。这时存在一个问题，我们在同一个事务中，对数据库查询两次，但两次的结果是不一样的。（这种方式称为不可重复读。）\n- 3、repetition read（可重读：**默认情况下使用**）。事务A对数据进行修改，但未提交，此时开启事务B，在事务B中不能读到事务A对数据库的修改。在事务A提交对数据库修改时，此时在事务B中，仍不能读到事务A对数据库的修改。（这种方式称为可重复读）但此时有一个弊端，比如我们在事务A中对数据库增加一条数据，id 为 n ，这时候我们在事务B中查询数据，此时查不到id为n的数据。但当我们在事务B中增加id为n的数据时，系统会提示id为n的数据已经存在，我们添加失败。但此时此刻，我们在事务B中仍不能查询到id为n的数据。这种方式存在一个幻读的概念。举个例子，（系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后关闭事务发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。）\n- 4、serializable（可串行化）。在开启事务A时，会产生锁表，此时别的事务会等待，等事务A结束时才会开启。\n\n[ MySQL数据库事务的四大特性以及事务的隔离级别](https://blog.csdn.net/l1394049664/article/details/81814090)\n\n\n",[[1553571891258,["28447@DESKTOP-BE7HQ26",[[1,7845,"\n"]],[7843,7843],[7844,7844]]],[1553571891477,["28447@DESKTOP-BE7HQ26",[[1,7846,"\n"]],[7844,7844],[7845,7845]]],[1553571891692,["28447@DESKTOP-BE7HQ26",[[1,7847,"\n"]],[7845,7845],[7846,7846]]],[1553587228686,["28447@DESKTOP-BE7HQ26",[[1,7750,"\n"]],[7749,7749],[7750,7750]]],[1553587228863,["28447@DESKTOP-BE7HQ26",[[1,7751,"\n"]],[7750,7750],[7751,7751]]],[1553588336566,["28447@DESKTOP-BE7HQ26",[[1,7752,"\n"]],[7750,7750],[7751,7751]]],[1553588336789,["28447@DESKTOP-BE7HQ26",[[1,7753,"\n"]],[7751,7751],[7752,7752]]],[1553588347644,["28447@DESKTOP-BE7HQ26",[[1,7751,"、什么情况下使用Runnable和Thread创建线程？"]],[7751,7751],[7779,7779]]],[1553588347755,["28447@DESKTOP-BE7HQ26",[[1,7783,"\n"]],[7779,7779],[7780,7780]]],[1553588352815,["28447@DESKTOP-BE7HQ26",[[-1,7750,"1、什么情况下使用Runnable和Thread创建线程？"]],[7750,7779],[7750,7750]]],[1553588354072,["28447@DESKTOP-BE7HQ26",[[1,7750,"****"]],[7750,7750],[7752,7752]]],[1553588354327,["28447@DESKTOP-BE7HQ26",[[1,7752,"1、什么情况下使用Runnable和Thread创建线程？"]],[7752,7752],[7781,7781]]],[1553588356120,["28447@DESKTOP-BE7HQ26",[[1,7788,"\n"]],[7783,7783],[7784,7784]]],[1553588776809,[null,[[-1,7786,"["],[1,7787,"\n"],[1,7789,"["]],[7786,7786],[7790,7790]]],[1553588776810,[null,[[1,7786,"["],[-1,7786,"\n"],[-1,7789,"["]],[7790,7790],[7786,7786]]],[1553588737061,["28447@DESKTOP-BE7HQ26",[[1,7784,"ruugo "]],[7784,7784],[7790,7790]]],[1553588738380,["28447@DESKTOP-BE7HQ26",[[-1,7784,"ruugo "]],[7790,7790],[7784,7784]]],[1553588741467,["28447@DESKTOP-BE7HQ26",[[1,7784,"入宫"]],[7784,7784],[7786,7786]]],[1553588742258,["28447@DESKTOP-BE7HQ26",[[-1,7784,"入宫"]],[7786,7786],[7784,7784]]],[1553588744036,["28447@DESKTOP-BE7HQ26",[[1,7784,"入宫"]],[7784,7784],[7786,7786]]],[1553588745607,["28447@DESKTOP-BE7HQ26",[[-1,7784,"入宫"]],[7786,7786],[7784,7784]]],[1553588757456,["28447@DESKTOP-BE7HQ26",[[1,7784,"如果问的是什么抢矿"]],[7784,7784],[7793,7793]]],[1553588758958,["28447@DESKTOP-BE7HQ26",[[-1,7791,"抢矿"]],[7793,7793],[7791,7791]]],[1553588774435,["28447@DESKTOP-BE7HQ26",[[1,7791,"情况下创建鲜血和曾"]],[7791,7791],[7800,7800]]],[1553588776389,["28447@DESKTOP-BE7HQ26",[[-1,7794,"创建鲜血和曾"]],[7800,7800],[7794,7794]]],[1553588836832,[null,[[-1,7796,"["],[1,7797,"\n"],[1,7799,"["]],[7796,7796],[7800,7800]]],[1553588836832,[null,[[1,7796,"["],[-1,7796,"\n"],[-1,7799,"["]],[7800,7800],[7796,7796]]],[1553588779985,["28447@DESKTOP-BE7HQ26",[[1,7794,"创建贤臣"]],[7794,7794],[7798,7798]]],[1553588781173,["28447@DESKTOP-BE7HQ26",[[-1,7796,"贤臣"]],[7798,7798],[7796,7796]]],[1553588783818,["28447@DESKTOP-BE7HQ26",[[1,7796,"线程"]],[7796,7796],[7798,7798]]],[1553588786866,["28447@DESKTOP-BE7HQ26",[[-1,7784,"如果"]],[7786,7786],[7784,7784]]],[1553588789798,["28447@DESKTOP-BE7HQ26",[[1,7784,"如果这句话"]],[7784,7784],[7789,7789]]],[1553588793380,["28447@DESKTOP-BE7HQ26",[[1,7801,"？"]],[7801,7801],[7802,7802]]],[1553588794008,["28447@DESKTOP-BE7HQ26",[[1,7807,"\n"]],[7802,7802],[7803,7803]]],[1553588794704,["28447@DESKTOP-BE7HQ26",[[1,7803,"  "]],[7803,7803],[7805,7805]]],[1553588797847,["28447@DESKTOP-BE7HQ26",[[-1,7803,"  "]],[7805,7805],[7803,7803]]],[1553588798383,["28447@DESKTOP-BE7HQ26",[[-1,7807,"\n"]],[7803,7803],[7802,7802]]],[1553588810847,["28447@DESKTOP-BE7HQ26",[[1,7802,"：在需要对共享变量"]],[7802,7802],[7811,7811]]],[1553589016823,[null,[[-1,7813,"["],[1,7814,"\n"],[1,7816,"["]],[7813,7813],[7817,7817]]],[1553589016823,[null,[[1,7813,"["],[-1,7813,"\n"],[-1,7816,"["]],[7817,7817],[7813,7813]]],[1553588967735,["28447@DESKTOP-BE7HQ26",[[1,7803,"多线程是为了提高效率"]],[7803,7803],[7813,7813]]],[1553588972807,["28447@DESKTOP-BE7HQ26",[[1,7811,"程序的"]],[7811,7811],[7814,7814]]],[1553588974229,["28447@DESKTOP-BE7HQ26",[[1,7816,"，"]],[7816,7816],[7817,7817]]],[1553588978749,["28447@DESKTOP-BE7HQ26",[[-1,7816,"，在需要对共享变量"]],[7816,7825],[7816,7816]]],[1553588979018,["28447@DESKTOP-BE7HQ26",[[1,7821,"\n"]],[7816,7816],[7817,7817]]],[1553588984379,["28447@DESKTOP-BE7HQ26",[[1,7817,"入宫"]],[7817,7817],[7819,7819]]],[1553588986136,["28447@DESKTOP-BE7HQ26",[[-1,7817,"入宫"]],[7819,7819],[7817,7817]]],[1553588999935,["28447@DESKTOP-BE7HQ26",[[1,7817,"如果问的是什么情况下使用"]],[7817,7817],[7829,7829]]],[1553589001829,["28447@DESKTOP-BE7HQ26",[[-1,7822,"什么情况下使用"]],[7829,7829],[7822,7822]]],[1553589010210,["28447@DESKTOP-BE7HQ26",[[1,7822,"Runnable和Thread的区别？："]],[7822,7822],[7842,7842]]],[1553589010409,["28447@DESKTOP-BE7HQ26",[[1,7847,"\n"]],[7842,7842],[7843,7843]]],[1553589012032,["28447@DESKTOP-BE7HQ26",[[1,7803,"\n"]],[7803,7803],[7804,7804]]],[1553589076820,[null,[[-1,7844,"["],[1,7845,"\n"],[1,7849,"["]],[7844,7844],[7850,7850]]],[1553589076820,[null,[[1,7844,"["],[-1,7844,"\n"],[-1,7849,"["]],[7850,7850],[7844,7844]]],[1553589017901,["28447@DESKTOP-BE7HQ26",[[1,7804,"\n"]],[7804,7804],[7805,7805]]],[1553589018780,["28447@DESKTOP-BE7HQ26",[[-1,7804,"\n"]],[7805,7805],[7804,7804]]],[1553589019089,["28447@DESKTOP-BE7HQ26",[[1,7804," "]],[7804,7804],[7805,7805]]],[1553589019670,["28447@DESKTOP-BE7HQ26",[[-1,7804," "]],[7805,7805],[7804,7804]]],[1553589020049,["28447@DESKTOP-BE7HQ26",[[1,7804,"  "]],[7804,7804],[7806,7806]]],[1553589055865,["28447@DESKTOP-BE7HQ26",[[1,7846,"  Runnable和Thread都可以实现run方法，但一个是接口，一个是类，前者可以无限地创建Thread进行run，而后者进行一次run之后就无法再次run。注意：Thread执行了start之后不可以再次执行start"]],[7846,7846],[7959,7959]]],[1553589061294,["28447@DESKTOP-BE7HQ26",[[1,7784,"- "]],[7784,7784],[7786,7786]]],[1553589065276,["28447@DESKTOP-BE7HQ26",[[1,7848,"-"]],[7848,7848],[7849,7849]]],[1553589065793,["28447@DESKTOP-BE7HQ26",[[1,7851," "]],[7849,7849],[7850,7850]]],[1553589066702,["28447@DESKTOP-BE7HQ26",[[-1,7851," "]],[7850,7850],[7849,7849]]],[1553589071833,["28447@DESKTOP-BE7HQ26",[[-1,7848,"- "]],[7850,7850],[7848,7848]]],[1553589073194,["28447@DESKTOP-BE7HQ26",[[1,7822,"- "]],[7822,7822],[7824,7824]]],[1553589076004,["28447@DESKTOP-BE7HQ26",[[1,7963," \n"]],[7962,7962],[7964,7964]]],[1553589085204,[null,[[-1,7962,"["],[1,7963,"\n"],[1,7969,"["]],[7962,7962],[7970,7970]]],[1553589085204,[null,[[1,7962,"["],[-1,7962,"\n"],[-1,7969,"["]],[7970,7970],[7962,7962]]],[1553589084100,["28447@DESKTOP-BE7HQ26",[[1,7962,"，****"]],[7962,7962],[7965,7965]]],[1553589084435,["28447@DESKTOP-BE7HQ26",[[1,7965,"因此，要实现线程能重复运行，如果采用XXX extends Thread，那么每次运行都必须new一个XXX，这十分损耗资源；如果使用XXX implements Runnable，那每次运行只需要新开一个线程new Thread(xxx)即可，节省了很多时空消耗"]],[7965,7965],[8097,8097]]],[1553589145208,[null,[[-1,8099,"["],[1,8100,"\n"],[1,8106,"["]],[8099,8099],[8107,8107]]],[1553589145208,[null,[[1,8099,"["],[-1,8099,"\n"],[-1,8106,"["]],[8107,8107],[8099,8099]]],[1553589093681,["28447@DESKTOP-BE7HQ26",[[-1,8100," "],[1,8101,"\n"]],[8101,8101],[8101,8101]]],[1553589095634,["28447@DESKTOP-BE7HQ26",[[1,8101,"****"]],[8101,8101],[8103,8103]]],[1553589096362,["28447@DESKTOP-BE7HQ26",[[1,8103,"3、"]],[8103,8103],[8105,8105]]],[1553589097163,["28447@DESKTOP-BE7HQ26",[[-1,8103,"3、"]],[8105,8105],[8103,8103]]],[1553589103315,["28447@DESKTOP-BE7HQ26",[[1,8103,"2、Runnable和Callable的区别"]],[8103,8103],[8125,8125]]],[1553589205205,[null,[[-1,8099,"["],[1,8100,"\n"],[1,8132,"["]],[8099,8099],[8133,8133]]],[1553589205205,[null,[[1,8099,"["],[-1,8099,"\n"],[-1,8132,"["]],[8133,8133],[8099,8099]]],[1553589148299,["28447@DESKTOP-BE7HQ26",[[1,8132,"\n"]],[8127,8127],[8128,8128]]],[1553589157848,["28447@DESKTOP-BE7HQ26",[[1,8128,"- 相同点：1.  两者都是接口；（废话）\n2.  两者都可用来编写多线程程序；\n3.  两者都需要调用Thread.start()启动线程；"]],[8128,8128],[8199,8199]]],[1553589160032,["28447@DESKTOP-BE7HQ26",[[1,8134,"\n"]],[8134,8134],[8135,8135]]],[1553589162433,["28447@DESKTOP-BE7HQ26",[[1,8135,"-  "]],[8135,8135],[8138,8138]]],[1553589163981,["28447@DESKTOP-BE7HQ26",[[-1,8137," "]],[8138,8138],[8137,8137]]],[1553589165035,["28447@DESKTOP-BE7HQ26",[[1,8135,"  "]],[8135,8135],[8137,8137]]],[1553589167789,["28447@DESKTOP-BE7HQ26",[[1,8155,"- "]],[8155,8155],[8157,8157]]],[1553589169506,["28447@DESKTOP-BE7HQ26",[[1,8155,"  "]],[8155,8155],[8157,8157]]],[1553589171467,["28447@DESKTOP-BE7HQ26",[[1,8178,"- "]],[8178,8178],[8180,8180]]],[1553589174317,["28447@DESKTOP-BE7HQ26",[[1,8178,"  "]],[8178,8178],[8180,8180]]],[1553589178801,["28447@DESKTOP-BE7HQ26",[[1,8213,"  - "]],[8212,8213],[8217,8217]]],[1553589182586,["28447@DESKTOP-BE7HQ26",[[-1,8214," - "]],[8217,8217],[8214,8214]]],[1553589190790,["28447@DESKTOP-BE7HQ26",[[1,8214,"- 不同点："]],[8214,8214],[8220,8220]]],[1553589191031,["28447@DESKTOP-BE7HQ26",[[1,8221," - \n"]],[8220,8220],[8224,8224]]],[1553589192398,["28447@DESKTOP-BE7HQ26",[[1,8222,"  "]],[8224,8224],[8226,8226]]],[1553589202556,["28447@DESKTOP-BE7HQ26",[[1,8226,"1.  两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；"]],[8226,8226],[8290,8290]]],[1553589204424,["28447@DESKTOP-BE7HQ26",[[1,8291,"   - \n"]],[8290,8290],[8296,8296]]],[1553589204940,["28447@DESKTOP-BE7HQ26",[[1,8296,"=-"]],[8296,8296],[8298,8298]]],[1553589232755,[null,[[-1,8099,"["],[1,8100,"\n"],[1,8302,"["]],[8099,8099],[8303,8303]]],[1553589232755,[null,[[1,8099,"["],[-1,8099,"\n"],[-1,8302,"["]],[8303,8303],[8099,8099]]],[1553589205475,["28447@DESKTOP-BE7HQ26",[[-1,8297,"-"]],[8298,8298],[8297,8297]]],[1553589205877,["28447@DESKTOP-BE7HQ26",[[1,8297,"2"]],[8297,8297],[8298,8298]]],[1553589206391,["28447@DESKTOP-BE7HQ26",[[-1,8296,"=2"]],[8298,8298],[8296,8296]]],[1553589215479,["28447@DESKTOP-BE7HQ26",[[1,8296,"2. Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛"]],[8296,8296],[8361,8361]]],[1553589224743,["28447@DESKTOP-BE7HQ26",[[-1,8225," "]],[8226,8226],[8225,8225]]],[1553589225394,["28447@DESKTOP-BE7HQ26",[[1,8225," "]],[8225,8225],[8226,8226]]],[1553589227010,["28447@DESKTOP-BE7HQ26",[[-1,8227,"."]],[8228,8228],[8227,8227]]],[1553589227802,["28447@DESKTOP-BE7HQ26",[[1,8227,"、"]],[8227,8227],[8228,8228]]],[1553589230801,["28447@DESKTOP-BE7HQ26",[[-1,8227,"、"]],[8228,8228],[8227,8227]]],[1553589231412,["28447@DESKTOP-BE7HQ26",[[1,8227,"."]],[8227,8227],[8228,8228]]],[1553589285219,[null,[[-1,8099,"["],[1,8100,"\n"],[1,8365,"["]],[8099,8099],[8366,8366]]],[1553589285219,[null,[[1,8099,"["],[-1,8099,"\n"],[-1,8365,"["]],[8366,8366],[8099,8099]]],[1553589250345,["28447@DESKTOP-BE7HQ26",[[-1,8150,"（废话）"]],[8150,8154],[8150,8150]]],[1553589263564,["28447@DESKTOP-BE7HQ26",[[1,8128,"\n"]],[8127,8127],[8128,8128]]],[1553589264131,["28447@DESKTOP-BE7HQ26",[[1,8128,"[]"]],[8128,8128],[8130,8130]]],[1553589265227,["28447@DESKTOP-BE7HQ26",[[-1,8128,"[]"]],[8130,8130],[8128,8128]]],[1553589271134,["28447@DESKTOP-BE7HQ26",[[1,8360,"【】"]],[8360,8360],[8362,8362]]],[1553589271700,["28447@DESKTOP-BE7HQ26",[[-1,8360,"【】"]],[8362,8362],[8360,8360]]],[1553589272716,["28447@DESKTOP-BE7HQ26",[[1,8360,"[]"]],[8360,8360],[8362,8362]]],[1553589280217,["28447@DESKTOP-BE7HQ26",[[-1,8364,"[Callable,Runnable比较及用法以及创建线程的4种方法](https://blog.csdn.net/xyw591238/article/details/51900325)\n"]],[8364,8458],[8364,8364]]],[1553589283584,["28447@DESKTOP-BE7HQ26",[[1,7697,"\n"]],[7696,7696],[7697,7697]]],[1553589284163,["28447@DESKTOP-BE7HQ26",[[1,7696,"[Callable,Runnable比较及用法以及创建线程的4种方法](https://blog.csdn.net/xyw591238/article/details/51900325)\n"]],[7696,7696],[7790,7790]]],[1553589306872,[null,[[-1,8194,"["],[1,8195,"\n"],[1,8457,"\n"]],[8194,8194],[8458,8458]]],[1553589306872,[null,[[1,8194,"["],[-1,8194,"\n"],[-1,8457,"\n"]],[8458,8458],[8194,8194]]],[1553589294458,["28447@DESKTOP-BE7HQ26",[[1,8456,"# [说说Runnable与Callable](https://www.cnblogs.com/frinder6/p/5507082.html)"]],[8456,8456],[8528,8528]]],[1553589297528,["28447@DESKTOP-BE7HQ26",[[-1,8456,"# ["]],[8458,8458],[8455,8455]]],[1553589304378,["28447@DESKTOP-BE7HQ26",[[-1,8525,"]"]],[8526,8526],[8525,8525]]],[1553589322452,[null,[[-1,8194,"["],[1,8195,"\n"],[1,8525,"\n"]],[8194,8194],[8526,8526]]],[1553589322452,[null,[[1,8194,"["],[-1,8194,"\n"],[-1,8525,"\n"]],[8526,8526],[8194,8194]]],[1553589310700,["28447@DESKTOP-BE7HQ26",[[-1,8456,"说说"]],[8458,8458],[8456,8456]]],[1553589314019,["28447@DESKTOP-BE7HQ26",[[1,8473,"yi"]],[8473,8473],[8475,8475]]],[1553589314481,["28447@DESKTOP-BE7HQ26",[[-1,8473,"yi"]],[8475,8475],[8473,8473]]],[1553589321983,["28447@DESKTOP-BE7HQ26",[[1,8473,"异同"]],[8473,8473],[8475,8475]]],[1553589382455,[null,[[-1,8194,"["],[1,8195,"\n"],[1,8525,"\n"]],[8194,8194],[8526,8526]]],[1553589382455,[null,[[1,8194,"["],[-1,8194,"\n"],[-1,8525,"\n"]],[8526,8526],[8194,8194]]],[1553589372585,["28447@DESKTOP-BE7HQ26",[[1,8314,"- \n "]],[8312,8312],[8316,8316]]],[1553589373608,["28447@DESKTOP-BE7HQ26",[[1,8314,"  "]],[8316,8316],[8318,8318]]],[1553589376011,["28447@DESKTOP-BE7HQ26",[[1,8318,"1.Callable规定的方法是call(),Runnable规定的方法是run()."]],[8318,8318],[8361,8361]]],[1553589377768,["28447@DESKTOP-BE7HQ26",[[1,8320," "]],[8320,8320],[8321,8321]]],[1553589381170,["28447@DESKTOP-BE7HQ26",[[-1,8368,"1"]],[8369,8369],[8368,8368]]],[1553589381356,["28447@DESKTOP-BE7HQ26",[[1,8368,"2"]],[8368,8368],[8369,8369]]],[1553589403495,[null,[[-1,8194,"["],[1,8195,"\n"],[1,8575,"\n"]],[8194,8194],[8576,8576]]],[1553589403495,[null,[[1,8194,"["],[-1,8194,"\n"],[-1,8575,"\n"]],[8576,8576],[8194,8194]]],[1553589384694,["28447@DESKTOP-BE7HQ26",[[-1,8371," "]],[8372,8372],[8371,8371]]],[1553589386929,["28447@DESKTOP-BE7HQ26",[[-1,8437,"2"]],[8438,8438],[8437,8437]]],[1553589387067,["28447@DESKTOP-BE7HQ26",[[1,8437,"3"]],[8437,8437],[8438,8438]]],[1553589388891,["28447@DESKTOP-BE7HQ26",[[1,8503,"   - \n"]],[8502,8502],[8508,8508]]],[1553589402268,["28447@DESKTOP-BE7HQ26",[[1,8508,"4. 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果"]],[8508,8508],[8620,8620]]],[1553589414390,[null,[[-1,8194,"["],[1,8195,"\n"],[1,8692,"\n"]],[8194,8194],[8693,8693]]],[1553589414390,[null,[[1,8194,"["],[-1,8194,"\n"],[-1,8692,"\n"]],[8693,8693],[8194,8194]]],[1553589408314,["28447@DESKTOP-BE7HQ26",[[-1,8361,"."]],[8362,8362],[8361,8361]]],[1553589409237,["28447@DESKTOP-BE7HQ26",[[1,8361,";"]],[8361,8361],[8362,8362]]],[1553589413599,["28447@DESKTOP-BE7HQ26",[[1,8620,"."]],[8620,8620],[8621,8621]]],[1553589534413,[null,[[-1,8194,"["],[1,8195,"\n"],[1,8693,"\n"]],[8194,8194],[8694,8694]]],[1553589534413,[null,[[1,8194,"["],[-1,8194,"\n"],[-1,8693,"\n"]],[8694,8694],[8194,8194]]],[1553589525097,["28447@DESKTOP-BE7HQ26",[[1,8694,"[Callable,Runnable比较及用法以及创建线程的4种方法](https://blog.csdn.net/xyw591238/article/details/51900325)"]],[8694,8694],[8787,8787]]],[1553589528982,["28447@DESKTOP-BE7HQ26",[[1,8694,"\n"]],[8693,8693],[8694,8694]]],[1553589533064,["28447@DESKTOP-BE7HQ26",[[1,7696,"\n"]],[7695,7695],[7696,7696]]],[1553589594396,[null,[[-1,8195,"["],[1,8196,"\n"],[1,8789,"\n"]],[8195,8195],[8790,8790]]],[1553589594396,[null,[[1,8195,"["],[-1,8195,"\n"],[-1,8789,"\n"]],[8790,8790],[8195,8195]]],[1553589551111,["28447@DESKTOP-BE7HQ26",[[1,8791,"### 线程方法中的异常如何处理，副线程可以捕获到吗?"]],[8791,8791],[8818,8818]]],[1553589551345,["28447@DESKTOP-BE7HQ26",[[1,8821,"\n"]],[8818,8818],[8819,8819]]],[1553589569289,["28447@DESKTOP-BE7HQ26",[[1,8822,"\n"]],[8819,8819],[8820,8820]]],[1553589569469,["28447@DESKTOP-BE7HQ26",[[1,8823,"\n"]],[8820,8820],[8821,8821]]],[1553590134425,[null,[[-1,8195,"["],[1,8196,"\n"],[-1,8820,"#"],[1,8821,"\n"],[1,8824,"#"]],[8195,8195],[8825,8825]]],[1553590134425,[null,[[1,8195,"["],[-1,8195,"\n"],[1,8820,"#"],[-1,8820,"\n"],[-1,8824,"#"]],[8825,8825],[8195,8195]]],[1553590095209,["28447@DESKTOP-BE7HQ26",[[1,8824,"\n"]],[8818,8818],[8819,8819]]],[1553590095396,["28447@DESKTOP-BE7HQ26",[[1,8825,"\n"]],[8819,8819],[8820,8820]]],[1553590100296,["28447@DESKTOP-BE7HQ26",[[1,8820,"获取线程"]],[8820,8820],[8824,8824]]],[1553590101134,["28447@DESKTOP-BE7HQ26",[[-1,8820,"获取线程"]],[8824,8824],[8820,8820]]],[1553590106874,["28447@DESKTOP-BE7HQ26",[[1,8820,"捕获线程种的"]],[8820,8820],[8826,8826]]],[1553590107351,["28447@DESKTOP-BE7HQ26",[[-1,8824,"种的"]],[8826,8826],[8824,8824]]],[1553590111251,["28447@DESKTOP-BE7HQ26",[[1,8824,"中一场的"]],[8824,8824],[8828,8828]]],[1553590113259,["28447@DESKTOP-BE7HQ26",[[-1,8825,"一场的"]],[8828,8828],[8825,8825]]],[1553590117868,["28447@DESKTOP-BE7HQ26",[[1,8825,"异常的方式："]],[8825,8825],[8831,8831]]],[1553590194413,[null,[[-1,8195,"["],[1,8196,"\n"],[-1,8831,"#"],[1,8832,"\n"],[1,8837,"#"]],[8195,8195],[8838,8838]]],[1553590194413,[null,[[1,8195,"["],[-1,8195,"\n"],[1,8831,"#"],[-1,8831,"\n"],[-1,8837,"#"]],[8838,8838],[8195,8195]]],[1553590146167,["28447@DESKTOP-BE7HQ26",[[1,8831,"（）"]],[8831,8831],[8833,8833]]],[1553590158752,["28447@DESKTOP-BE7HQ26",[[1,8832,"使用try{}catch（"]],[8832,8832],[8845,8845]]],[1553590159060,["28447@DESKTOP-BE7HQ26",[[1,8846,"）"]],[8845,8845],[8846,8846]]],[1553590160250,["28447@DESKTOP-BE7HQ26",[[1,8845,"fan"]],[8845,8845],[8848,8848]]],[1553590161056,["28447@DESKTOP-BE7HQ26",[[-1,8845,"fan"]],[8848,8848],[8845,8845]]],[1553590167477,["28447@DESKTOP-BE7HQ26",[[1,8846,"方式捕获不到一茶馆"]],[8846,8846],[8855,8855]]],[1553590168436,["28447@DESKTOP-BE7HQ26",[[-1,8852,"一茶馆"]],[8855,8855],[8852,8852]]],[1553590170149,["28447@DESKTOP-BE7HQ26",[[1,8852,"异常"]],[8852,8852],[8854,8854]]],[1553590173305,["28447@DESKTOP-BE7HQ26",[[-1,8860,"\n"]],[8856,8856],[8855,8855]]],[1553590254413,[null,[[-1,8195,"["],[1,8196,"\n"],[-1,8855,"#"],[1,8856,"\n"],[1,8860,"#"]],[8195,8195],[8861,8861]]],[1553590254413,[null,[[1,8195,"["],[-1,8195,"\n"],[1,8855,"#"],[-1,8855,"\n"],[-1,8860,"#"]],[8861,8861],[8195,8195]]],[1553590220648,["28447@DESKTOP-BE7HQ26",[[1,8832,"单纯"]],[8832,8832],[8834,8834]]],[1553590240972,["28447@DESKTOP-BE7HQ26",[[1,8858,"- ## Thread方式通过线程组,线程名，并设置UncaughtExceptionHandler来捕获异常"]],[8858,8858],[8913,8913]]],[1553590243098,["28447@DESKTOP-BE7HQ26",[[-1,8860,"##"]],[8860,8862],[8860,8860]]],[1553590245646,["28447@DESKTOP-BE7HQ26",[[1,8860,"方式一："]],[8860,8860],[8864,8864]]],[1553590249656,["28447@DESKTOP-BE7HQ26",[[1,8916,"```"]],[8916,8916],[8919,8919]]],[1553590249712,["28447@DESKTOP-BE7HQ26",[[1,8919,"language\n```\n"]],[8919,8919],[8919,8927]]],[1553590250539,["28447@DESKTOP-BE7HQ26",[[-1,8919,"language"],[1,8927,"k"]],[8919,8927],[8920,8920]]],[1553590250937,["28447@DESKTOP-BE7HQ26",[[-1,8919,"k"]],[8920,8920],[8919,8919]]],[1553590251651,["28447@DESKTOP-BE7HQ26",[[1,8919,"java"]],[8919,8919],[8923,8923]]],[1553590252114,["28447@DESKTOP-BE7HQ26",[[1,8924,"\n"]],[8923,8923],[8924,8924]]],[1553590314419,[null,[[-1,8195,"["],[1,8196,"\n"],[-1,8857,"#"],[1,8858,"\n"],[1,8932,"#"]],[8195,8195],[8933,8933]]],[1553590314419,[null,[[1,8195,"["],[-1,8195,"\n"],[1,8857,"#"],[-1,8857,"\n"],[-1,8932,"#"]],[8933,8933],[8195,8195]]],[1553590255687,["28447@DESKTOP-BE7HQ26",[[1,8924,"public static void main(String[] args) {\n        try{\n            Thread t =new Thread(new Runnable(){\n                @Override\n                public void run() {\n                    int i = 10/0;\n                    System.out.println(\"run....\");\n                }\n            });\n            t.setUncaughtExceptionHandler(\n                new UncaughtExceptionHandler() {\n                @Override\n                public void uncaughtException(Thread t,   Throwable e) {\n                    System.out.println(\"catch 到了\");\n                }\n            });\n            t.start();\n        }catch(Exception e){\n            System.out.println(\"catch 不到\");\n        }\n    }"]],[8924,8924],[9596,9596]]],[1553590261512,["28447@DESKTOP-BE7HQ26",[[1,9604,"\n"]],[9600,9600],[9601,9601]]],[1553590261697,["28447@DESKTOP-BE7HQ26",[[1,9605,"\n"]],[9601,9601],[9602,9602]]],[1553590413992,[null,[[-1,8195,"["],[1,8196,"\n"],[-1,8857,"#"],[1,8858,"\n"],[1,9606,"#"]],[8195,8195],[9607,9607]]],[1553590413992,[null,[[1,8195,"["],[-1,8195,"\n"],[1,8857,"#"],[-1,8857,"\n"],[-1,9606,"#"]],[9607,9607],[8195,8195]]],[1553590402511,["28447@DESKTOP-BE7HQ26",[[1,9597,"    \n"]],[9596,9596],[9601,9601]]],[1553590405031,["28447@DESKTOP-BE7HQ26",[[1,9601,"//输入"]],[9601,9601],[9605,9605]]],[1553590405758,["28447@DESKTOP-BE7HQ26",[[-1,9603,"输入"]],[9605,9605],[9603,9603]]],[1553590413322,["28447@DESKTOP-BE7HQ26",[[1,9603,"输出： catch 到了"]],[9603,9603],[9615,9615]]],[1553590429939,[null,[[-1,8195,"["],[1,8196,"\n"],[-1,8857,"#"],[1,8858,"\n"],[1,9625,"#"]],[8195,8195],[9626,9626]]],[1553590429939,[null,[[1,8195,"["],[-1,8195,"\n"],[1,8857,"#"],[-1,8857,"\n"],[-1,9625,"#"]],[9626,9626],[8195,8195]]],[1553590424840,["28447@DESKTOP-BE7HQ26",[[1,8886,"****"]],[8886,8886],[8888,8888]]],[1553590428292,["28447@DESKTOP-BE7HQ26",[[-1,8890,"UncaughtExceptionHandler"]],[8890,8914],[8890,8890]]],[1553590429305,["28447@DESKTOP-BE7HQ26",[[1,8888,"UncaughtExceptionHandler"]],[8888,8888],[8912,8912]]],[1553590489947,[null,[[-1,8195,"["],[1,8196,"\n"],[-1,8857,"#"],[1,8858,"\n"],[1,9629,"#"]],[8195,8195],[9630,9630]]],[1553590489947,[null,[[1,8195,"["],[-1,8195,"\n"],[1,8857,"#"],[-1,8857,"\n"],[-1,9629,"#"]],[9630,9630],[8195,8195]]],[1553590432949,["28447@DESKTOP-BE7HQ26",[[1,9629,"\n"]],[9623,9623],[9624,9624]]],[1553590433366,["28447@DESKTOP-BE7HQ26",[[1,9630,"\n"]],[9624,9624],[9625,9625]]],[1553590443290,["28447@DESKTOP-BE7HQ26",[[-1,9630,"\n"]],[9625,9625],[9624,9624]]],[1553590446927,["28447@DESKTOP-BE7HQ26",[[1,9624,"-  方式2"]],[9624,9624],[9630,9630]]],[1553590451031,["28447@DESKTOP-BE7HQ26",[[-1,9629,"2"]],[9630,9630],[9629,9629]]],[1553590453861,["28447@DESKTOP-BE7HQ26",[[1,9629,"二： ## ExecutorService"]],[9629,9629],[9650,9650]]],[1553590458248,["28447@DESKTOP-BE7HQ26",[[-1,9632,"## "]],[9632,9634],[9632,9632]]],[1553590459473,["28447@DESKTOP-BE7HQ26",[[1,9632,"shi"]],[9632,9632],[9635,9635]]],[1553590460462,["28447@DESKTOP-BE7HQ26",[[-1,9632,"shi"]],[9635,9635],[9632,9632]]],[1553590461974,["28447@DESKTOP-BE7HQ26",[[1,9632,"使用"]],[9632,9632],[9634,9634]]],[1553590468533,["28447@DESKTOP-BE7HQ26",[[1,9649,"捕获下称"]],[9649,9649],[9653,9653]]],[1553590468957,["28447@DESKTOP-BE7HQ26",[[1,9654,"- \n"]],[9653,9653],[9656,9656]]],[1553590469906,["28447@DESKTOP-BE7HQ26",[[-1,9654,"- "]],[9656,9656],[9654,9654]]],[1553590470169,["28447@DESKTOP-BE7HQ26",[[-1,9659,"\n"]],[9654,9654],[9653,9653]]],[1553590470920,["28447@DESKTOP-BE7HQ26",[[-1,9651,"下称"]],[9653,9653],[9651,9651]]],[1553590473441,["28447@DESKTOP-BE7HQ26",[[1,9651,"线程"]],[9651,9651],[9653,9653]]],[1553590473858,["28447@DESKTOP-BE7HQ26",[[1,9654,"- \n"]],[9653,9653],[9656,9656]]],[1553590474564,["28447@DESKTOP-BE7HQ26",[[-1,9654,"- "]],[9656,9656],[9655,9655]]],[1553597150077,[null,[[-1,8195,"["],[1,8196,"\n"],[-1,8857,"#"],[1,8858,"\n"],[1,9660,"#"]],[8195,8195],[9661,9661]]],[1553597150077,[null,[[1,8195,"["],[-1,8195,"\n"],[1,8857,"#"],[-1,8857,"\n"],[-1,9660,"#"]],[9661,9661],[8195,8195]]],[1553597128170,["28447@DESKTOP-BE7HQ26",[[1,9654,"- \n"]],[9653,9653],[9656,9656]]],[1553597128384,["28447@DESKTOP-BE7HQ26",[[-1,9654,"- "]],[9656,9656],[9655,9655]]],[1553598058312,[null,[[-1,8195,"["],[1,8196,"\n"],[-1,8857,"#"],[1,8858,"\n"],[1,9661,"#"]],[8195,8195],[9662,9662]]],[1553598058312,[null,[[1,8195,"["],[-1,8195,"\n"],[1,8857,"#"],[-1,8857,"\n"],[-1,9661,"#"]],[9662,9662],[8195,8195]]],[1553598028495,["28447@DESKTOP-BE7HQ26",[[-1,9624,"-  方式二： 使用ExecutorService捕获线程"]],[9624,9653],[9624,9624]]],[1553598033994,["28447@DESKTOP-BE7HQ26",[[-1,8860,"方式一："]],[8860,8863],[8860,8860]]],[1553599078337,[null,[[-1,8195,"["],[1,8196,"\n"],[-1,8857,"#"],[1,8858,"\n"],[1,9628,"#"]],[8195,8195],[9629,9629]]],[1553599078337,[null,[[1,8195,"["],[-1,8195,"\n"],[1,8857,"#"],[-1,8857,"\n"],[-1,9628,"#"]],[9629,9629],[8195,8195]]],[1553599062167,["28447@DESKTOP-BE7HQ26",[[1,9622,"### ****"]],[9622,9622],[9628,9628]]],[1553599062718,["28447@DESKTOP-BE7HQ26",[[1,9628,"synchronized和锁的区别，什么情况下使用synchronized和ReentrantLock"]],[9628,9628],[9679,9679]]],[1553599064185,["28447@DESKTOP-BE7HQ26",[[1,9687,"\n"]],[9681,9681],[9682,9682]]],[1553599064852,["28447@DESKTOP-BE7HQ26",[[1,9688,"\n"]],[9682,9682],[9683,9683]]],[1553599066720,["28447@DESKTOP-BE7HQ26",[[1,9683,"****"]],[9683,9683],[9685,9685]]],[1553599067588,["28447@DESKTOP-BE7HQ26",[[1,9685,"1\\"]],[9685,9685],[9687,9687]]],[1553599068464,["28447@DESKTOP-BE7HQ26",[[-1,9686,"\\"]],[9687,9687],[9686,9686]]],[1553599072862,["28447@DESKTOP-BE7HQ26",[[1,9686,"、synchronized和锁的区别"]],[9686,9686],[9704,9704]]],[1553599074228,["28447@DESKTOP-BE7HQ26",[[1,9712,"\n"]],[9706,9706],[9707,9707]]]],null,"28447@DESKTOP-BE7HQ26"],["db88aed0-4a0b-4576-8d7b-bac2f6c6acf5",1553676273314,"# Java知识点\n\n\n##  集合、线程\n\n\n\n### **HashTable实现原理，HashMap实现原理，ConcurrentHashMap实现原理**\n[1、jdk1.7 HashMap原理](https://www.cnblogs.com/chengxiao/p/6059914.html)\n[ 2、Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析](http://www.importnew.com/28263.html)\n[ 3、ConcurrentHashMap在jdk1.8中的改进](https://www.cnblogs.com/everSeeker/p/5601861.html)\n\n**jdk1.8 HashMap结构图：**\n![2](https://javadoop.com/blogimages/map/2.png)\n\n**jdk1.8实现方式与jdk1.7不同：**\n- HashMap和ConcurrentHashMap都加入了**红黑树**，对于个数超过8个（默认值）的列表，jdk1.8采用红黑树的结构，查询的时间复杂度可以降到O(logN)\n- ConcurrentHashMap：取消segments字段，直接采用transient volatile HashEntry<K,V>[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率\n\n**以下为jdk1.7实现方式**\n**HashTable**\n*   底层数组+单向链表实现，无论key还是value都**不能为null**，线程**安全**，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化\n*   初始size为**11**，扩容：newsize = olesize*2+1\n*   计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length\n\n**HashMap**\n*   底层数组+单向链表实现，可**以存储null键和null值**，线程**不安全**\n*   初始size为**16**，扩容：newsize = oldsize*2，size一定为2的n次幂\n*   扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入\n*   插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）\n*   当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀\n*   计算index方法：index = hash & (tab.length – 1)\n\nHashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。\n```java\n//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。\ntransient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;\n```\nHashMap和Hashtable都是用hash算法来决定其元素的存储，因此HashMap和Hashtable的hash表包含如下属性：\n\n*   容量（capacity）：hash表中桶的数量\n*   初始化容量（initial capacity）：创建hash表时桶的数量，HashMap允许在构造器中指定初始化容量\n*   尺寸（size）：当前hash表中记录的数量\n*   负载因子（load factor）：负载因子等于“size/capacity”。负载因子为0，表示空的hash表，0.5表示半满的散列表，依此类推。轻负载的散列表具有冲突少、适宜插入与查询的特点（但是使用Iterator迭代元素时比较慢）\n\n除此之外，hash表里还有一个“负载极限”，“负载极限”是一个0～1的数值，“负载极限”决定了hash表的最大填满程度。当hash表中的负载因子达到指定的“负载极限”时，hash表会自动成倍地增加容量（桶的数量），并将原有的对象重新分配，放入新的桶内，这称为rehashing。\n\n**“负载极限”的默认值（0.75）是时间和空间成本上的一种折中**\n\n*   较高的“负载极限”可以降低hash表所占用的内存空间，但会增加查询数据的时间开销，而查询是最频繁的操作（HashMap的get()与put()方法都要用到查询）\n*   较低的“负载极限”会提高查询数据的性能，但会增加hash表所占用的内存开销\n\n![](https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png)\n\n\n**ConcurrentHashMap**\n*   底层采用分段的数组+单向链表实现，线程**安全**\n*   通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)\n*   Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术\n*   有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁\n*   扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容\n\n\nConcurrentHashMap比HashMap多出了一个类Segment，而Segment是一个可重入锁。\n\nConcurrentHashMap是使用了锁分段技术来保证线程安全的。\n\n**锁分段技术**：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 \n\nConcurrentHashMap提供了与Hashtable和SynchronizedMap不同的锁机制。**Hashtable中采用的锁机制是一次锁住整个hash表**，从而在同一时刻只能由一个线程对其进行操作；而**ConcurrentHashMap中则是一次锁住一个桶**。\n\nConcurrentHashMap默认将hash表分为16个桶，诸如get、put、remove等常用操作只锁住当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。\n\n\n### **HashMap在高并发环境下会产生的问题**\n 问题：\n - HashMap死循环，照成CPU100%负载\n - 触发fail-fast\n\n**1、HashMap死循环的原因**\n\nHashMap进行存储时，如果size超过（当前最大容量*负载因子）时候会发生resize，首先看一下resize源代码：\n```java\nvoid resize(int newCapacity) { \n  Entry[] oldTable = table; \n  int oldCapacity =  oldTable.length; \n  if (oldCapacity == MAXIMUM_CAPACITY) { \n      threshold = Integer.MAX_VALUE; \n      return; \n   } \n  Entry[] newTable = new Entry[newCapacity]; \n  // transfer方法是真正执行rehash的操作，容易在高并发时发生问题 \n  transfer(newTable); \n  table = newTable; \n  threshold = (int)(newCapacity * loadFactor); \n}\n```\n**而这段代码中又调用了transfer()方法，而这个方法实现的机制就是将每个链表转化到新链表，并且链表中的位置发生反转，而这在多线程情况下是很容易造成链表回路，从而发生死循环**，我们看一下他的源代码:\n```java\nvoid tansfer(Entry[] newTable) {\n\t   Entry[] src = table;\n\t   int newCapacity = newTable.length;\n\t   for (int j = 0; j < src.length; j++) {\n\t       Entry<K,V> e = src[j];\n\t       if (e != null) {\n\t           src[j] = null;\n\t           do {\n\t               Entry<K,V> next = e.next;\n\t               int i = indexFor(e.hash, newCapacity);\n\t               e.next = newTable[i];\n\t               newTable[i] = e;\n\t               e = next;\n\t           } while (e != null);\n\t       }\n\t   }\n\t}\n```\n**2、触发fail-fast：**\n**一个线程利用迭代器迭代时，另一个线程做插入删除操作，造成迭代的fast-fail。**\n```java\npublic class TestFailFast {\n    \n    private static final String USER_NAME_PREFIX = \"User-\";\n    // Key: User Name, Value: User Age\n    private static Map<String, Integer> userMap = new HashMap<>();\n    \n    // ThreadA 用于向HashMap添加元素\n    static class ThreadA implements Runnable {\n        @Override\n        public void run() {\n            System.out.println(\"ThreadA starts to add user.\");\n            for (int i = 1; i < 100000; i++) {\n                userMap.put(USER_NAME_PREFIX+i, i%100);\n            }\n            System.out.println(\"ThreadA done.\");\n        }\n    }\n    \n    // ThreadB 用于遍历HashMap中元素输出\n    static class ThreadB implements Runnable {\n        @Override\n        public void run() {\n            System.out.println(\"ThreadB starts to iterate.\");\n            for (Map.Entry<String, Integer> user : userMap.entrySet()) {\n                System.out.println(\"UserName=\" + user.getKey()\n                    + \", UserAge=\" + user.getValue());\n            }\n            System.out.println(\"ThreadB done.\");\n        }\n    }\n    \n    public static void main(String[] args) throws InterruptedException {\n        Thread threadA = new Thread(new ThreadA());\n        Thread threadB = new Thread(new ThreadB());\n    \n        threadA.start();\n        threadB.start();\n  \n        threadA.join();\n        threadB.join();\n        System.exit(0);\n    }\n}\n```\n运行结果：抛出ConcurrentModificationException\n\n\n\n\n\n\n\n\n\n\n\n\n### **红黑树，为什么允许局部不平衡**\n\n\n\n\n\n### **什么是一致性Hash算法**\n\n原因：\n应用场景：redis缓存假设使用普通hash取模的方式。在增加节点或减少节点时，映射规则将被改变，当应用无法从缓存中获取数据，则会想后端数据库请求数据\n\n![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbhiae1AfNYAibdp7ib2wTZTrpnNGzjcWYy3ylL7s1Bq2UKicU5mYG8SHsuIFTOf2PMe2FstpM2gMeQbw/640)\n\n- hash值是个整数非负，非负整数的值范围做成一个圆环`Hash环`（0——2^32-1）；\n- 对集群的节点的某个属性（比如节点名）求hash值，放在环上；\n- 对数据key求hash值，也放在环上，按顺时针方向找到离它最近的节点，放在它上面。\n\n`附` 如何避免Hash环的数据倾斜？\n\n引入`虚拟节点`，例如将每台服务器就算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点\n![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbhiae1AfNYAibdp7ib2wTZTrpnNGzjcWYy3ylL7s1Bq2UKicU5mYG8SHsuIFTOf2PMe2FstpM2gMeQbw/640)\n\n[参考文章](https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368)\n\n### 有哪几种常用的线程池\n\n线程简介：线程是操作系统能够进行运算调度的最小单位，线程有就绪，阻塞，运行三种基本状态。\n\n线程池概念：线程池是一种多线程处理形式，处理过程中将任务添加队列，然后在创建线程后自动启动这些任务，每个线程都使用默认的堆栈大小，以默认的优先级运行，并处在多线程单元中，如果某个线程在托管代码中空闲，则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后辅助线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才能启动。\n\njava里面的线程池的顶级接口是**Executor**，Executor并不是一个线程池，而只是一个执行线程的工具，而真正的线程池是**ExecutorService**。\n\n**java中的有哪些线程池？**\n- 1.newCachedThreadPool创建一个可缓存线程池程\n- 2.newFixedThreadPool 创建一个定长线程池\n- 3.newScheduledThreadPool 创建一个定长线程池\n- 4.newSingleThreadExecutor 创建一个单线程化的线程池\n\n**1、newCachedThreadPool**是一种线程数量不定的线程池，并且其最大线程数为Integer.MAX_VALUE，这个数是很大的，一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。但是线程池中的空闲线程都有超时限制，这个超时时长是60秒，超过60秒闲置线程就会被回收。调用execute将重用以前构造的线程(如果线程可用)。这类线程池比较适合执行大量的耗时较少的任务，当整个线程池都处于闲置状态时，线程池中的线程都会超时被停止。\n\n**2.newFixedThreadPool** 创建一个指定工作线程数量的线程池，每当提交一个任务就创建一个工作线程，当线程 处于空闲状态时，它们并不会被回收，除非线程池被关闭了，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列（没有大小限制）中。由于newFixedThreadPool只有核心线程并且这些核心线程不会被回收，这样它更加快速底相应外界的请求。\n\n**3.newScheduledThreadPool **创建一个线程池，它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收，它可安排给定延迟后运行命令或者定期地执行。这类线程池主要用于执行定时任务和具有固定周期的重复任务。\n\n**4.newSingleThreadExecutor**这类线程池内部只有一个核心线程，以无界队列方式来执行该线程，这使得这些任务之间不需要处理线程同步的问题，它确保所有的任务都在同一个线程中按顺序中执行，并且可以在任意给定的时间不会有多个线程是活动的。\n[ java中的线程池有哪些，分别有什么作用？](https://blog.csdn.net/qq_33453910/article/details/81413285)\n\n[Callable,Runnable比较及用法以及创建线程的4种方法](https://blog.csdn.net/xyw591238/article/details/51900325)\n\n\n### 什么情况下使用Runnable和Thread创建线程，Runnable和Callable的区别\n\n**1、什么情况下使用Runnable和Thread创建线程？**\n- 如果这句话问的是什么情况下创建线程？：\n  多线程是为了提高程序的效率\n- 如果问的是Runnable和Thread的区别？：\n Runnable和Thread都可以实现run方法，但一个是接口，一个是类，前者可以无限地创建Thread进行run，而后者进行一次run之后就无法再次run。注意：Thread执行了start之后不可以再次执行start，**因此，要实现线程能重复运行，如果采用XXX extends Thread，那么每次运行都必须new一个XXX，这十分损耗资源；如果使用XXX implements Runnable，那每次运行只需要新开一个线程new Thread(xxx)即可，节省了很多时空消耗**\n\n**2、Runnable和Callable的区别**\n\n- 相同点：\n  - 1.  两者都是接口；\n  - 2.  两者都可用来编写多线程程序；\n  - 3.  两者都需要调用Thread.start()启动线程；\n - 不同点：\n   - 1. Callable规定的方法是call(),Runnable规定的方法是run();\n   - 2. 两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；\n   - 3. Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛\n   - 4. 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果.\n\n[Runnable与Callable异同](https://www.cnblogs.com/frinder6/p/5507082.html)\n\n[Callable,Runnable比较及用法以及创建线程的4种方法](https://blog.csdn.net/xyw591238/article/details/51900325)\n\n### 线程方法中的异常如何处理，副线程可以捕获到吗?\n\n捕获线程中异常的方式：（单纯使用try{}catch（）方式捕获不到异常）\n-  Thread方式通过线程组,线程名，并设置**UncaughtExceptionHandler**来捕获异常\n```java\npublic static void main(String[] args) {\n        try{\n            Thread t =new Thread(new Runnable(){\n                @Override\n                public void run() {\n                    int i = 10/0;\n                    System.out.println(\"run....\");\n                }\n            });\n            t.setUncaughtExceptionHandler(\n                new UncaughtExceptionHandler() {\n                @Override\n                public void uncaughtException(Thread t,   Throwable e) {\n                    System.out.println(\"catch 到了\");\n                }\n            });\n            t.start();\n        }catch(Exception e){\n            System.out.println(\"catch 不到\");\n        }\n    }\n    //输出： catch 到了\n```\n\n\n### **synchronized和锁的区别，什么情况下使用synchronized和ReentrantLock**\n\n**1、synchronized和锁的区别**\n\n\n\n\n\n\n## **网络**\n\n### **TCP三次握手**\n  - 第一次握手：建立连接时，客户端发送syn（Synchronize Sequence Numbers：同步序列编号）包（sny=1）到服务器，并进入SYN_SEND（请求连接）状态，等待服务器确认;\n  - 第二次握手：服务器接收到syn包，必须确认客户的syn（ack=j+1）（ack：确认字符，表示发来的数据已确认接收无误），同时自己也发送一个syn包（sny=k），既ack+syn包，此时服务器进入SYN_RECV（发送了ACK时的状态）状态。\n  - 第三次握手：客户端收到服务端发送的syn+ack包，向服务端发送确认包ack（sny+1既ack=k+1），此包发送完毕，客户端与服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n  \n![TCP三次握手图](https://img-blog.csdn.net/20180830135313575?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nemhhb3lhbmcxMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n### **TCP四次挥手**\n\n  - 第一次挥手：TCP客户端发送一个FIN+ACK+SEQ，用来传输关闭客户端到服务端的数据。进入FIN_WAIT1状态。\n  - 第二次挥手：服务端收到FIN，被动发送一个ACK（SEQ+1）,进入CLOSE_WAIT状态，客户端收到服务端发送的ACK，进入FIN_WAIT2状态。\n  - 第三次挥手：服务器关闭客户端连接，发送一个FIN给+ACK+SEQ客户端。进入LAST_ACK状态。\n  - 第四次挥手：客户端发送ACK（ACK=SQE序号+1）报文确认，客户端进入TIME_WAIT状态，服务端收到ACK进入CLOSE状态。\n  \n![](https://img-blog.csdn.net/20180830142208139?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nemhhb3lhbmcxMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n### **说说几种HTTP响应码**\n      ☆ 200 OK：表示客户端请求成功。\n      ☆ 400 Bad Request 语义有误，不能被当前服务器理解。\n      ☆ 401 Unauthorized 当前请求需要用户验证。\n      ☆ 403 Forbidden 服务器收到消息，但是拒绝提供服务。\n      ☆ 404 Not Found 请求资源不存在。\n      ☆ 408 Request Timeout 请求超时，客户端没有在服务器预备等待的时间内完成发送。\n      ☆ 500 Internal Server Error 服务器发生不可预期的错误。\n      ☆ 503 Server Unavailable 由于临时的服务器维护或过载，服务器当前不能处理请求，此状况知识临时的，可恢复\n\n### **当你用浏览器打开一个链接时，计算机做了哪些步骤**\n  - 1、解析域名\n  - 2、发次TCP的3次握手\n  - 3、建立TCP请求后发起HTTP请求\n  - 4、服务器相应的HTTP请求\n  - 5、浏览器得到HTML代码，进行解析和处理JSON数据，并请求HTML代码中的静态资源（JS、CSS、图片等）\n  - 6、浏览器对页面进行渲染 \n\n[网络面试知识点1](https://blog.csdn.net/zhengzhaoyang122/article/details/82184072)\n[网络面试知识点2](https://www.cnblogs.com/huajiezh/p/7492416.html)\n\n### **TCP，UDP区别，为什么可靠和不可靠**\n\n![1553517637]($resource/1553517637.png)\n\n- 1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接\n- 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付\n- 3、TCP面向字节流，有流量拥塞控制。实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）\n- 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 \n- 5、TCP首部开销20字节;UDP的首部开销小，只有8个字节 \n- 6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道\n\n**为什么可靠和不可靠：**\nUDP:\nUDP只有一个socket接受缓冲区，没有socket发送缓冲区，即只要有数据就发，不管对方是否可以正确接受。而在对方的socket接受缓冲区满了之后，新来的数据报无法进入到socket接受缓冲区，此数据报就会被丢弃，udp是没有流量控制的，故UDP的数据传输是不可靠的。\nTCP：\n每个Tcp socket在内核中都有一个发送缓冲区和一个接受缓冲区。tcp协议要求对端在接受到tcp数据报之后，要对其序号进行ACK，只有当接受到一个tcp数据报的ACK之后，才可以把这个tcp数据报从socket的发送缓冲区清除，另外tcp还有一个流量控制功能，tcp的socket接受缓冲区接受到网络上来的数据缓存起来后，如果应用程序一直没有读取，\n\nsocket接受缓冲区满了之后，发生的动作是：通知对端TCP协议中的窗口关闭，这便是滑动窗口的实现，保证TCP socket接受缓冲区不会溢出，因为对方不允许发送超过所通知窗口大小的数据， 这就是TCP的流量控制，如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方TCP将丢弃它。这两点保证了tcp是可靠传输的。\n\n## MySQL事务是什么？四大特性、四大隔离级别\n\n**事务**：事务是由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。程序和事务是两个不同的概念。一般而言：**一段程序中可能包含多个事务**。（**说白了就是几步的数据库操作而构成的逻辑执行单元**）\n\n**四大特性：**\n- 原子性：事务是一个不可分割的整体，事务开始的操作，要么全部执行，要么全部不执行\n- 隔离性：同一时间，只允许一个事务请求同一组数据。不同的事务彼此之间没有干扰。\n- 一致性：事务开始前和结束后，数据库的完整性约束没有被破坏 。\n- 稳定性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。\n\n**四大隔离级别**\n- 1、read uncommitted（读取未提交内容）。事务A对数据进行修改，但未提交。此时开启事务B，在事务B中能读到事务A中对数据库进行的未提交数据的修改。（这种方式也称为**脏读**）\n- 2、read committed（读取提交内容）。事务A对数据进行修改，但还未提交。此时开启事务B，在事务B中不能读到事务A中对数据库的修改。在事务B还没有关闭时，此时事务A提交对数据库的修改。这时候，我们在事务B中，可以查到事务A中对数据库的修改。这时存在一个问题，我们在同一个事务中，对数据库查询两次，但两次的结果是不一样的。（这种方式称为不可重复读。）\n- 3、repetition read（可重读：**默认情况下使用**）。事务A对数据进行修改，但未提交，此时开启事务B，在事务B中不能读到事务A对数据库的修改。在事务A提交对数据库修改时，此时在事务B中，仍不能读到事务A对数据库的修改。（这种方式称为可重复读）但此时有一个弊端，比如我们在事务A中对数据库增加一条数据，id 为 n ，这时候我们在事务B中查询数据，此时查不到id为n的数据。但当我们在事务B中增加id为n的数据时，系统会提示id为n的数据已经存在，我们添加失败。但此时此刻，我们在事务B中仍不能查询到id为n的数据。这种方式存在一个幻读的概念。举个例子，（系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后关闭事务发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。）\n- 4、serializable（可串行化）。在开启事务A时，会产生锁表，此时别的事务会等待，等事务A结束时才会开启。\n\n[ MySQL数据库事务的四大特性以及事务的隔离级别](https://blog.csdn.net/l1394049664/article/details/81814090)\n\n\n",[[1553676230106,["28447@DESKTOP-BE7HQ26",[[1,13492,"\n"]],[13489,13489],[13490,13490]]],[1553676231563,["28447@DESKTOP-BE7HQ26",[[1,13490,"###"]],[13490,13490],[13493,13493]]],[1553676232689,["28447@DESKTOP-BE7HQ26",[[-1,13492,"#"]],[13493,13493],[13492,13492]]],[1553676234424,["28447@DESKTOP-BE7HQ26",[[1,13492," 算法"]],[13492,13492],[13495,13495]]],[1553676234950,["28447@DESKTOP-BE7HQ26",[[1,13498,"\n"]],[13495,13495],[13496,13496]]],[1553676240327,["28447@DESKTOP-BE7HQ26",[[1,13496,"### 开拍"]],[13496,13496],[13502,13502]]],[1553676240832,["28447@DESKTOP-BE7HQ26",[[1,13505,"\n"]],[13502,13502],[13503,13503]]],[1553676241140,["28447@DESKTOP-BE7HQ26",[[-1,13505,"\n"]],[13503,13503],[13502,13502]]],[1553676241577,["28447@DESKTOP-BE7HQ26",[[-1,13500,"开拍"]],[13502,13502],[13500,13500]]],[1553676246758,["28447@DESKTOP-BE7HQ26",[[1,13500,"快拍"]],[13500,13500],[13502,13502]]],[1553676247100,["28447@DESKTOP-BE7HQ26",[[1,13505,"\n"]],[13502,13502],[13503,13503]]],[1553676247574,["28447@DESKTOP-BE7HQ26",[[-1,13505,"\n"]],[13503,13503],[13502,13502]]],[1553676247781,["28447@DESKTOP-BE7HQ26",[[-1,13501,"拍"]],[13502,13502],[13501,13501]]],[1553676249551,["28447@DESKTOP-BE7HQ26",[[1,13501,"排序"]],[13501,13501],[13503,13503]]],[1553676249829,["28447@DESKTOP-BE7HQ26",[[-1,13502,"序"]],[13503,13503],[13502,13502]]],[1553676250202,["28447@DESKTOP-BE7HQ26",[[1,13505,"\n"]],[13502,13502],[13503,13503]]],[1553676250407,["28447@DESKTOP-BE7HQ26",[[1,13506,"\n"]],[13503,13503],[13504,13504]]],[1553676250607,["28447@DESKTOP-BE7HQ26",[[1,13507,"\n"]],[13504,13504],[13505,13505]]],[1553676252248,["28447@DESKTOP-BE7HQ26",[[1,13505,"```"]],[13505,13505],[13508,13508]]],[1553676252297,["28447@DESKTOP-BE7HQ26",[[1,13508,"language\n```\n"]],[13508,13508],[13508,13516]]],[1553676253350,["28447@DESKTOP-BE7HQ26",[[-1,13508,"language"],[1,13516,"j"]],[13508,13516],[13509,13509]]],[1553676253737,["28447@DESKTOP-BE7HQ26",[[1,13509,"ava"]],[13509,13509],[13512,13512]]],[1553676254166,["28447@DESKTOP-BE7HQ26",[[1,13513,"\n"]],[13512,13512],[13513,13513]]],[1553676254604,["28447@DESKTOP-BE7HQ26",[[1,13513,"void quickSort(int[] num, int start, int end) {\n\t\tif (num.length == 0)\n\t\t\treturn;\n\t\tif (start >= end)\n\t\t\treturn;\n\n\t\tint low = start;\n\t\tint high = end;\n\t\tint temp = num[low];\n\t\twhile (low < high) {\n\t\t\twhile (low < high && num[high] > temp) {\n\t\t\t\thigh--;\n\t\t\t}\n\t\t\tnum[low] = num[high];\n\t\t\twhile (low < high &&num[low] <= temp) {\n\t\t\t\tlow++;\n\t\t\t}\n\t\t\tnum[high] = num[low];\n\t\t}\n\t\tnum[low] = temp;\n\t\tquickSort(num, start, low - 1);\n\t\tquickSort(num, high + 1, end);\n\n\t}"]],[13513,13513],[13973,13973]]],[1553676268396,["28447@DESKTOP-BE7HQ26",[[-1,13562,"\t"]],[13562,13563],[13562,13562]]],[1553676269963,["28447@DESKTOP-BE7HQ26",[[-1,13595,"\t"]],[13595,13596],[13595,13595]]],[1553676271134,["28447@DESKTOP-BE7HQ26",[[-1,13585,"\t"]],[13586,13586],[13585,13585]]],[1553676274532,["28447@DESKTOP-BE7HQ26",[[-1,13614,"\t"]],[13614,13614],[13613,13613]]],[1553676276107,["28447@DESKTOP-BE7HQ26",[[-1,13624,"\t"]],[13625,13625],[13624,13624]]],[1553676277288,["28447@DESKTOP-BE7HQ26",[[-1,13642,"\t"]],[13643,13643],[13642,13642]]],[1553676278032,["28447@DESKTOP-BE7HQ26",[[-1,13659,"\t"]],[13660,13660],[13659,13659]]],[1553676278714,["28447@DESKTOP-BE7HQ26",[[-1,13681,"\t"]],[13682,13682],[13681,13681]]],[1553676279547,["28447@DESKTOP-BE7HQ26",[[-1,13704,"\t"]],[13705,13705],[13704,13704]]],[1553676281112,["28447@DESKTOP-BE7HQ26",[[-1,13748,"\t"]],[13749,13749],[13748,13748]]],[1553676289147,["28447@DESKTOP-BE7HQ26",[[-1,13758,"\t"]],[13759,13759],[13758,13758]]],[1553676294696,["28447@DESKTOP-BE7HQ26",[[-1,13846,"\t"]],[13847,13847],[13846,13846]]],[1553676298398,["28447@DESKTOP-BE7HQ26",[[-1,13873,"\t"]],[13874,13874],[13873,13873]]],[1553676299135,["28447@DESKTOP-BE7HQ26",[[-1,13891,"\t"]],[13892,13892],[13891,13891]]],[1553676299742,["28447@DESKTOP-BE7HQ26",[[-1,13924,"\t"]],[13925,13925],[13924,13924]]],[1553676300804,["28447@DESKTOP-BE7HQ26",[[-1,13956,"\t"]],[13957,13957],[13956,13956]]],[1553676301972,["28447@DESKTOP-BE7HQ26",[[-1,13869,"\t"]],[13870,13870],[13869,13869]]],[1553676307404,["28447@DESKTOP-BE7HQ26",[[-1,13845,"\t"]],[13846,13846],[13845,13845]]],[1553676316025,["28447@DESKTOP-BE7HQ26",[[-1,13762,"\t"]],[13763,13763],[13762,13762]]],[1553676317096,["28447@DESKTOP-BE7HQ26",[[-1,13786,"\t"]],[13787,13787],[13786,13786]]],[1553676318224,["28447@DESKTOP-BE7HQ26",[[-1,13829,"\t"]],[13830,13830],[13829,13829]]],[1553676319863,["28447@DESKTOP-BE7HQ26",[[-1,13838,"\t"]],[13839,13839],[13838,13838]]],[1553676325149,["28447@DESKTOP-BE7HQ26",[[1,13841,"    "]],[13841,13841],[13845,13845]]],[1553676326851,["28447@DESKTOP-BE7HQ26",[[-1,13844," "]],[13845,13845],[13844,13844]]],[1553676328866,["28447@DESKTOP-BE7HQ26",[[-1,13837,"\t"]],[13838,13838],[13837,13837]]],[1553676332496,["28447@DESKTOP-BE7HQ26",[[1,13837,"  "]],[13837,13837],[13839,13839]]],[1553676384590,["28447@DESKTOP-BE7HQ26",[[1,13960,"[]"]],[13960,13960],[13962,13962]]],[1553676394269,["28447@DESKTOP-BE7HQ26",[[1,13961,"快速排序基本思想"]],[13961,13961],[13969,13969]]],[1553676395385,["28447@DESKTOP-BE7HQ26",[[1,13970,"("]],[13970,13970],[13971,13971]]],[1553676395444,["28447@DESKTOP-BE7HQ26",[[1,13971,"https://)"]],[13971,13971],[13971,13979]]],[1553676396094,["28447@DESKTOP-BE7HQ26",[[1,13979,"blog.csdn.net/nrsc272420199/article/details/82587933"]],[13971,13979],[14031,14031]]],[1553676958188,["28447@DESKTOP-BE7HQ26",[[1,9713,"\n"]],[9706,9706],[9707,9707]]],[1553676958465,["28447@DESKTOP-BE7HQ26",[[1,9714,"\n"]],[9707,9707],[9708,9708]]],[1553677054839,["28447@DESKTOP-BE7HQ26",[[1,9707,"- Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；"]],[9707,9707],[9780,9780]]],[1553677056024,["28447@DESKTOP-BE7HQ26",[[1,9781,"- \n"]],[9780,9780],[9783,9783]]],[1553677061813,["28447@DESKTOP-BE7HQ26",[[1,9783,"Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。\n--------------------- \n作者：赵尽朝 \n来源：CSDN \n原文：https://blog.csdn.net/z15732621582/article/details/81841415 \n版权声明：本文为博主原创文章，转载请附上博文链接！"]],[9783,9783],[10061,10061]]],[1553677065748,["28447@DESKTOP-BE7HQ26",[[-1,9932,"--------------------- \n作者：赵尽朝 \n来源：CSDN \n原文：https://blog.csdn.net/z15732621582/article/details/81841415 \n版权声明：本文为博主原创文章，转载请附上博文链接！\n"]],[9932,10062],[9932,9932]]],[1553677076732,["28447@DESKTOP-BE7HQ26",[[-1,9783,"Lock和synchronized有一点非常大的不同，"]],[9783,9810],[9783,9783]]],[1553677080295,["28447@DESKTOP-BE7HQ26",[[-1,9903,"。"]],[9904,9904],[9903,9903]]],[1553677081424,["28447@DESKTOP-BE7HQ26",[[1,9903,";"]],[9903,9903],[9904,9904]]],[1553677081831,["28447@DESKTOP-BE7HQ26",[[1,9905,"- \n"]],[9904,9904],[9907,9907]]],[1553677141600,["28447@DESKTOP-BE7HQ26",[[1,9907,"用法不一样。synchronized既可以加在方法上，也可以加载特定的代码块上，括号中表示需要锁的对象。而Lock需要显示地指定起始位置和终止位置。synchronzied是托管给jvm执行的，Lock锁定是通过代码实现的。"]],[9907,9907],[10019,10019]]],[1553677143246,["28447@DESKTOP-BE7HQ26",[[-1,10018,"。"]],[10019,10019],[10018,10018]]],[1553677144226,["28447@DESKTOP-BE7HQ26",[[1,10018,";"]],[10018,10018],[10019,10019]]],[1553677144563,["28447@DESKTOP-BE7HQ26",[[1,10020,"- \n"]],[10019,10019],[10022,10022]]],[1553677160607,["28447@DESKTOP-BE7HQ26",[[1,10022,"锁的机制不一样。synchronized获得锁和释放的方式都是在块结构中，而且是自动释放锁。而Lock则需要开发人员手动去释放，并且必须在finally块中释放，否则会引起死锁问题的发生;"]],[10022,10022],[10116,10116]]],[1553677160978,["28447@DESKTOP-BE7HQ26",[[1,10117,"- \n"]],[10116,10116],[10119,10119]]],[1553677167831,["28447@DESKTOP-BE7HQ26",[[1,10119,"Lock是一个接口，而synchronized是Java中的关键字,synchronized是内置的语言实现；"]],[10119,10119],[10174,10174]]],[1553677180804,["28447@DESKTOP-BE7HQ26",[[-1,10119,"Lock是一个接口，而synchronized是Java中的关键字,synchronized是内置的语言实现；\n"]],[10119,10175],[10119,10119]]],[1553677189495,["28447@DESKTOP-BE7HQ26",[[1,10119,"synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；"]],[10119,10119],[10232,10232]]],[1553677191276,["28447@DESKTOP-BE7HQ26",[[1,10233,"- \n"]],[10232,10232],[10235,10235]]],[1553677216197,["28447@DESKTOP-BE7HQ26",[[1,10235,"Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。Lock可以提高多个线程进行读操作的效率"]],[10235,10235],[10365,10365]]],[1553677249616,["28447@DESKTOP-BE7HQ26",[[1,10367,"****"]],[10367,10367],[10369,10369]]],[1553677250168,["28447@DESKTOP-BE7HQ26",[[1,10369,"什么情况下使用synchronized和ReentrantLock"]],[10369,10369],[10402,10402]]],[1553677251887,["28447@DESKTOP-BE7HQ26",[[1,10409,"\n"]],[10404,10404],[10405,10405]]],[1553691391429,["28447@DESKTOP-BE7HQ26",[[1,14658,"1\\"]],[14658,14658],[14660,14660]]],[1553691392742,["28447@DESKTOP-BE7HQ26",[[-1,14659,"\\"]],[14660,14660],[14659,14659]]],[1553691393120,["28447@DESKTOP-BE7HQ26",[[1,14659,"、"]],[14659,14659],[14660,14660]]],[1553691396927,["28447@DESKTOP-BE7HQ26",[[1,14101,"1、 "]],[14101,14101],[14104,14104]]],[1553691404335,["28447@DESKTOP-BE7HQ26",[[1,11984,"1、"]],[11984,11984],[11986,11986]]],[1553691406646,["28447@DESKTOP-BE7HQ26",[[1,12062,"2、"]],[12062,12062],[12064,12064]]],[1553691409181,["28447@DESKTOP-BE7HQ26",[[1,12061,"\n"]],[12060,12060],[12061,12061]]],[1553691426679,["28447@DESKTOP-BE7HQ26",[[1,8625,"1、 "]],[8625,8625],[8628,8628]]],[1553691427680,["28447@DESKTOP-BE7HQ26",[[-1,8627," "]],[8628,8628],[8627,8627]]],[1553691431238,["28447@DESKTOP-BE7HQ26",[[1,8699,"2、 "]],[8699,8699],[8702,8702]]],[1553691437142,["28447@DESKTOP-BE7HQ26",[[1,7613,"1、"]],[7613,7613],[7615,7615]]],[1553691440138,["28447@DESKTOP-BE7HQ26",[[1,7700,"2、"]],[7700,7700],[7702,7702]]],[1553691445530,["28447@DESKTOP-BE7HQ26",[[1,7735,"。"]],[7735,7735],[7736,7736]]],[1553691447786,["28447@DESKTOP-BE7HQ26",[[-1,7735,"。"]],[7736,7736],[7735,7735]]],[1553691452983,["28447@DESKTOP-BE7HQ26",[[1,6313,"1、"]],[6313,6313],[6315,6315]]],[1553691463431,["28447@DESKTOP-BE7HQ26",[[1,152,"\n"]],[151,151],[152,152]]],[1553691465685,["28447@DESKTOP-BE7HQ26",[[1,238,"\n"]],[237,237],[238,238]]]],null,"28447@DESKTOP-BE7HQ26"],["ef9c3d8d-6410-4c6a-b3de-ad3f74eb4ed8",1556469485525,"# Java知识点\n\n\n##  集合、线程\n\n\n\n### **HashTable实现原理，HashMap实现原理，ConcurrentHashMap实现原理**\n[1、jdk1.7 HashMap原理](https://www.cnblogs.com/chengxiao/p/6059914.html)\n\n[ 2、Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析](http://www.importnew.com/28263.html)\n\n[ 3、ConcurrentHashMap在jdk1.8中的改进](https://www.cnblogs.com/everSeeker/p/5601861.html)\n\n**jdk1.8 HashMap结构图：**\n![2](https://javadoop.com/blogimages/map/2.png)\n\n**jdk1.8实现方式与jdk1.7不同：**\n- HashMap和ConcurrentHashMap都加入了**红黑树**，对于个数超过8个（默认值）的列表，jdk1.8采用红黑树的结构，查询的时间复杂度可以降到O(logN)\n- ConcurrentHashMap：取消segments字段，直接采用transient volatile HashEntry<K,V>[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率\n\n**以下为jdk1.7实现方式**\n**HashTable**\n*   底层数组+单向链表实现，无论key还是value都**不能为null**，线程**安全**，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化\n*   初始size为**11**，扩容：newsize = olesize*2+1\n*   计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length\n\n**HashMap**\n*   底层数组+单向链表实现，可**以存储null键和null值**，线程**不安全**\n*   初始size为**16**，扩容：newsize = oldsize*2，size一定为2的n次幂\n*   扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入\n*   插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）\n*   当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀\n*   计算index方法：index = hash & (tab.length – 1)\n\nHashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。\n```java\n//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。\ntransient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;\n```\nHashMap和Hashtable都是用hash算法来决定其元素的存储，因此HashMap和Hashtable的hash表包含如下属性：\n\n*   容量（capacity）：hash表中桶的数量\n*   初始化容量（initial capacity）：创建hash表时桶的数量，HashMap允许在构造器中指定初始化容量\n*   尺寸（size）：当前hash表中记录的数量\n*   负载因子（load factor）：负载因子等于“size/capacity”。负载因子为0，表示空的hash表，0.5表示半满的散列表，依此类推。轻负载的散列表具有冲突少、适宜插入与查询的特点（但是使用Iterator迭代元素时比较慢）\n\n除此之外，hash表里还有一个“负载极限”，“负载极限”是一个0～1的数值，“负载极限”决定了hash表的最大填满程度。当hash表中的负载因子达到指定的“负载极限”时，hash表会自动成倍地增加容量（桶的数量），并将原有的对象重新分配，放入新的桶内，这称为rehashing。\n\n**“负载极限”的默认值（0.75）是时间和空间成本上的一种折中**\n\n*   较高的“负载极限”可以降低hash表所占用的内存空间，但会增加查询数据的时间开销，而查询是最频繁的操作（HashMap的get()与put()方法都要用到查询）\n*   较低的“负载极限”会提高查询数据的性能，但会增加hash表所占用的内存开销\n\n![](https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png)\n\n\n**ConcurrentHashMap**\n*   底层采用分段的数组+单向链表实现，线程**安全**\n*   通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)\n*   Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术\n*   有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁\n*   扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容\n\n\nConcurrentHashMap比HashMap多出了一个类Segment，而Segment是一个可重入锁。\n\nConcurrentHashMap是使用了锁分段技术来保证线程安全的。\n\n**锁分段技术**：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 \n\nConcurrentHashMap提供了与Hashtable和SynchronizedMap不同的锁机制。**Hashtable中采用的锁机制是一次锁住整个hash表**，从而在同一时刻只能由一个线程对其进行操作；而**ConcurrentHashMap中则是一次锁住一个桶**。\n\nConcurrentHashMap默认将hash表分为16个桶，诸如get、put、remove等常用操作只锁住当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。\n\n\n### **HashMap在高并发环境下会产生的问题**\n 问题：\n - HashMap死循环，照成CPU100%负载\n - 触发fail-fast\n\n**1、HashMap死循环的原因**\n\nHashMap进行存储时，如果size超过（当前最大容量*负载因子）时候会发生resize，首先看一下resize源代码：\n```java\nvoid resize(int newCapacity) { \n  Entry[] oldTable = table; \n  int oldCapacity =  oldTable.length; \n  if (oldCapacity == MAXIMUM_CAPACITY) { \n      threshold = Integer.MAX_VALUE; \n      return; \n   } \n  Entry[] newTable = new Entry[newCapacity]; \n  // transfer方法是真正执行rehash的操作，容易在高并发时发生问题 \n  transfer(newTable); \n  table = newTable; \n  threshold = (int)(newCapacity * loadFactor); \n}\n```\n**而这段代码中又调用了transfer()方法，而这个方法实现的机制就是将每个链表转化到新链表，并且链表中的位置发生反转，而这在多线程情况下是很容易造成链表回路，从而发生死循环**，我们看一下他的源代码:\n```java\nvoid tansfer(Entry[] newTable) {\n\t   Entry[] src = table;\n\t   int newCapacity = newTable.length;\n\t   for (int j = 0; j < src.length; j++) {\n\t       Entry<K,V> e = src[j];\n\t       if (e != null) {\n\t           src[j] = null;\n\t           do {\n\t               Entry<K,V> next = e.next;\n\t               int i = indexFor(e.hash, newCapacity);\n\t               e.next = newTable[i];\n\t               newTable[i] = e;\n\t               e = next;\n\t           } while (e != null);\n\t       }\n\t   }\n\t}\n```\n**2、触发fail-fast：**\n**一个线程利用迭代器迭代时，另一个线程做插入删除操作，造成迭代的fast-fail。**\n```java\npublic class TestFailFast {\n    \n    private static final String USER_NAME_PREFIX = \"User-\";\n    // Key: User Name, Value: User Age\n    private static Map<String, Integer> userMap = new HashMap<>();\n    \n    // ThreadA 用于向HashMap添加元素\n    static class ThreadA implements Runnable {\n        @Override\n        public void run() {\n            System.out.println(\"ThreadA starts to add user.\");\n            for (int i = 1; i < 100000; i++) {\n                userMap.put(USER_NAME_PREFIX+i, i%100);\n            }\n            System.out.println(\"ThreadA done.\");\n        }\n    }\n    \n    // ThreadB 用于遍历HashMap中元素输出\n    static class ThreadB implements Runnable {\n        @Override\n        public void run() {\n            System.out.println(\"ThreadB starts to iterate.\");\n            for (Map.Entry<String, Integer> user : userMap.entrySet()) {\n                System.out.println(\"UserName=\" + user.getKey()\n                    + \", UserAge=\" + user.getValue());\n            }\n            System.out.println(\"ThreadB done.\");\n        }\n    }\n    \n    public static void main(String[] args) throws InterruptedException {\n        Thread threadA = new Thread(new ThreadA());\n        Thread threadB = new Thread(new ThreadB());\n    \n        threadA.start();\n        threadB.start();\n  \n        threadA.join();\n        threadB.join();\n        System.exit(0);\n    }\n}\n```\n运行结果：抛出ConcurrentModificationException\n\n\n\n\n\n\n\n\n\n\n\n\n### **红黑树，为什么允许局部不平衡**\n\n\n\n\n\n### **什么是一致性Hash算法**\n\n原因：\n应用场景：redis缓存假设使用普通hash取模的方式。在增加节点或减少节点时，映射规则将被改变，当应用无法从缓存中获取数据，则会想后端数据库请求数据\n\n![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbhiae1AfNYAibdp7ib2wTZTrpnNGzjcWYy3ylL7s1Bq2UKicU5mYG8SHsuIFTOf2PMe2FstpM2gMeQbw/640)\n\n- hash值是个整数非负，非负整数的值范围做成一个圆环`Hash环`（0——2^32-1）；\n- 对集群的节点的某个属性（比如节点名）求hash值，放在环上；\n- 对数据key求hash值，也放在环上，按顺时针方向找到离它最近的节点，放在它上面。\n\n`附` 如何避免Hash环的数据倾斜？\n\n引入`虚拟节点`，例如将每台服务器就算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点\n![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbhiae1AfNYAibdp7ib2wTZTrpnNGzjcWYy3ylL7s1Bq2UKicU5mYG8SHsuIFTOf2PMe2FstpM2gMeQbw/640)\n\n[1、参考文章](https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368)\n\n### 有哪几种常用的线程池\n\n线程简介：线程是操作系统能够进行运算调度的最小单位，线程有就绪，阻塞，运行三种基本状态。\n\n线程池概念：线程池是一种多线程处理形式，处理过程中将任务添加队列，然后在创建线程后自动启动这些任务，每个线程都使用默认的堆栈大小，以默认的优先级运行，并处在多线程单元中，如果某个线程在托管代码中空闲，则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后辅助线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才能启动。\n\njava里面的线程池的顶级接口是**Executor**，Executor并不是一个线程池，而只是一个执行线程的工具，而真正的线程池是**ExecutorService**。\n\n**java中的有哪些线程池？**\n- 1.newCachedThreadPool创建一个可缓存线程池程\n- 2.newFixedThreadPool 创建一个定长线程池\n- 3.newScheduledThreadPool 创建一个定长线程池\n- 4.newSingleThreadExecutor 创建一个单线程化的线程池\n\n**1、newCachedThreadPool**是一种线程数量不定的线程池，并且其最大线程数为Integer.MAX_VALUE，这个数是很大的，一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。但是线程池中的空闲线程都有超时限制，这个超时时长是60秒，超过60秒闲置线程就会被回收。调用execute将重用以前构造的线程(如果线程可用)。这类线程池比较适合执行大量的耗时较少的任务，当整个线程池都处于闲置状态时，线程池中的线程都会超时被停止。\n\n**2.newFixedThreadPool** 创建一个指定工作线程数量的线程池，每当提交一个任务就创建一个工作线程，当线程 处于空闲状态时，它们并不会被回收，除非线程池被关闭了，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列（没有大小限制）中。由于newFixedThreadPool只有核心线程并且这些核心线程不会被回收，这样它更加快速底相应外界的请求。\n\n**3.newScheduledThreadPool **创建一个线程池，它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收，它可安排给定延迟后运行命令或者定期地执行。这类线程池主要用于执行定时任务和具有固定周期的重复任务。\n\n**4.newSingleThreadExecutor**这类线程池内部只有一个核心线程，以无界队列方式来执行该线程，这使得这些任务之间不需要处理线程同步的问题，它确保所有的任务都在同一个线程中按顺序中执行，并且可以在任意给定的时间不会有多个线程是活动的。\n[ 1、java中的线程池有哪些，分别有什么作用？](https://blog.csdn.net/qq_33453910/article/details/81413285)\n\n[2、Callable,Runnable比较及用法以及创建线程的4种方法](https://blog.csdn.net/xyw591238/article/details/51900325)\n\n\n### 什么情况下使用Runnable和Thread创建线程，Runnable和Callable的区别\n\n**1、什么情况下使用Runnable和Thread创建线程？**\n- 如果这句话问的是什么情况下创建线程？：\n  多线程是为了提高程序的效率\n- 如果问的是Runnable和Thread的区别？：\n Runnable和Thread都可以实现run方法，但一个是接口，一个是类，前者可以无限地创建Thread进行run，而后者进行一次run之后就无法再次run。注意：Thread执行了start之后不可以再次执行start，**因此，要实现线程能重复运行，如果采用XXX extends Thread，那么每次运行都必须new一个XXX，这十分损耗资源；如果使用XXX implements Runnable，那每次运行只需要新开一个线程new Thread(xxx)即可，节省了很多时空消耗**\n\n**2、Runnable和Callable的区别**\n\n- 相同点：\n  - 1.  两者都是接口；\n  - 2.  两者都可用来编写多线程程序；\n  - 3.  两者都需要调用Thread.start()启动线程；\n - 不同点：\n   - 1. Callable规定的方法是call(),Runnable规定的方法是run();\n   - 2. 两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；\n   - 3. Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛\n   - 4. 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果.\n\n[1、Runnable与Callable异同](https://www.cnblogs.com/frinder6/p/5507082.html)\n\n[2、 Callable,Runnable比较及用法以及创建线程的4种方法](https://blog.csdn.net/xyw591238/article/details/51900325)\n\n### 线程方法中的异常如何处理，副线程可以捕获到吗?\n\n捕获线程中异常的方式：（单纯使用try{}catch（）方式捕获不到异常）\n-  Thread方式通过线程组,线程名，并设置**UncaughtExceptionHandler**来捕获异常\n```java\npublic static void main(String[] args) {\n        try{\n            Thread t =new Thread(new Runnable(){\n                @Override\n                public void run() {\n                    int i = 10/0;\n                    System.out.println(\"run....\");\n                }\n            });\n            t.setUncaughtExceptionHandler(\n                new UncaughtExceptionHandler() {\n                @Override\n                public void uncaughtException(Thread t,   Throwable e) {\n                    System.out.println(\"catch 到了\");\n                }\n            });\n            t.start();\n        }catch(Exception e){\n            System.out.println(\"catch 不到\");\n        }\n    }\n    //输出： catch 到了\n```\n\n\n### **synchronized和锁的区别，什么情况下使用synchronized和ReentrantLock**\n\n**1、synchronized和锁的区别**\n- Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；\n- 采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象;\n- 用法不一样。synchronized既可以加在方法上，也可以加载特定的代码块上，括号中表示需要锁的对象。而Lock需要显示地指定起始位置和终止位置。synchronzied是托管给jvm执行的，Lock锁定是通过代码实现的;\n- 锁的机制不一样。synchronized获得锁和释放的方式都是在块结构中，而且是自动释放锁。而Lock则需要开发人员手动去释放，并且必须在finally块中释放，否则会引起死锁问题的发生;\n- synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；\n- Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。Lock可以提高多个线程进行读操作的效率\n\n**什么情况下使用synchronized和ReentrantLock**\n\n\n\n\n\n## **网络**\n\n### **TCP三次握手**\n  - 第一次握手：建立连接时，客户端发送syn（Synchronize Sequence Numbers：同步序列编号）包（sny=1）到服务器，并进入SYN_SEND（请求连接）状态，等待服务器确认;\n  - 第二次握手：服务器接收到syn包，必须确认客户的syn（ack=j+1）（ack：确认字符，表示发来的数据已确认接收无误），同时自己也发送一个syn包（sny=k），既ack+syn包，此时服务器进入SYN_RECV（发送了ACK时的状态）状态。\n  - 第三次握手：客户端收到服务端发送的syn+ack包，向服务端发送确认包ack（sny+1既ack=k+1），此包发送完毕，客户端与服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n  \n![TCP三次握手图](https://img-blog.csdn.net/20180830135313575?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nemhhb3lhbmcxMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n### **TCP四次挥手**\n\n  - 第一次挥手：TCP客户端发送一个FIN+ACK+SEQ，用来传输关闭客户端到服务端的数据。进入FIN_WAIT1状态。\n  - 第二次挥手：服务端收到FIN，被动发送一个ACK（SEQ+1）,进入CLOSE_WAIT状态，客户端收到服务端发送的ACK，进入FIN_WAIT2状态。\n  - 第三次挥手：服务器关闭客户端连接，发送一个FIN给+ACK+SEQ客户端。进入LAST_ACK状态。\n  - 第四次挥手：客户端发送ACK（ACK=SQE序号+1）报文确认，客户端进入TIME_WAIT状态，服务端收到ACK进入CLOSE状态。\n  \n![](https://img-blog.csdn.net/20180830142208139?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nemhhb3lhbmcxMjI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n### **说说几种HTTP响应码**\n      ☆ 200 OK：表示客户端请求成功。\n      ☆ 400 Bad Request 语义有误，不能被当前服务器理解。\n      ☆ 401 Unauthorized 当前请求需要用户验证。\n      ☆ 403 Forbidden 服务器收到消息，但是拒绝提供服务。\n      ☆ 404 Not Found 请求资源不存在。\n      ☆ 408 Request Timeout 请求超时，客户端没有在服务器预备等待的时间内完成发送。\n      ☆ 500 Internal Server Error 服务器发生不可预期的错误。\n      ☆ 503 Server Unavailable 由于临时的服务器维护或过载，服务器当前不能处理请求，此状况知识临时的，可恢复\n\n### **当你用浏览器打开一个链接时，计算机做了哪些步骤**\n  - 1、解析域名\n  - 2、发次TCP的3次握手\n  - 3、建立TCP请求后发起HTTP请求\n  - 4、服务器相应的HTTP请求\n  - 5、浏览器得到HTML代码，进行解析和处理JSON数据，并请求HTML代码中的静态资源（JS、CSS、图片等）\n  - 6、浏览器对页面进行渲染 \n\n[1、网络面试知识点1](https://blog.csdn.net/zhengzhaoyang122/article/details/82184072)\n\n[2、网络面试知识点2](https://www.cnblogs.com/huajiezh/p/7492416.html)\n\n### **TCP，UDP区别，为什么可靠和不可靠**\n\n![1553517637]($resource/1553517637.png)\n\n- 1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接\n- 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付\n- 3、TCP面向字节流，有流量拥塞控制。实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）\n- 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 \n- 5、TCP首部开销20字节;UDP的首部开销小，只有8个字节 \n- 6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道\n\n**为什么可靠和不可靠：**\nUDP:\nUDP只有一个socket接受缓冲区，没有socket发送缓冲区，即只要有数据就发，不管对方是否可以正确接受。而在对方的socket接受缓冲区满了之后，新来的数据报无法进入到socket接受缓冲区，此数据报就会被丢弃，udp是没有流量控制的，故UDP的数据传输是不可靠的。\nTCP：\n每个Tcp socket在内核中都有一个发送缓冲区和一个接受缓冲区。tcp协议要求对端在接受到tcp数据报之后，要对其序号进行ACK，只有当接受到一个tcp数据报的ACK之后，才可以把这个tcp数据报从socket的发送缓冲区清除，另外tcp还有一个流量控制功能，tcp的socket接受缓冲区接受到网络上来的数据缓存起来后，如果应用程序一直没有读取，\n\nsocket接受缓冲区满了之后，发生的动作是：通知对端TCP协议中的窗口关闭，这便是滑动窗口的实现，保证TCP socket接受缓冲区不会溢出，因为对方不允许发送超过所通知窗口大小的数据， 这就是TCP的流量控制，如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方TCP将丢弃它。这两点保证了tcp是可靠传输的。\n\n## MySQL事务是什么？四大特性、四大隔离级别\n\n**事务**：事务是由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。程序和事务是两个不同的概念。一般而言：**一段程序中可能包含多个事务**。（**说白了就是几步的数据库操作而构成的逻辑执行单元**）\n\n**四大特性：**\n- 原子性：事务是一个不可分割的整体，事务开始的操作，要么全部执行，要么全部不执行\n- 隔离性：同一时间，只允许一个事务请求同一组数据。不同的事务彼此之间没有干扰。\n- 一致性：事务开始前和结束后，数据库的完整性约束没有被破坏 。\n- 稳定性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。\n\n**四大隔离级别**\n- 1、read uncommitted（读取未提交内容）。事务A对数据进行修改，但未提交。此时开启事务B，在事务B中能读到事务A中对数据库进行的未提交数据的修改。（这种方式也称为**脏读**）\n- 2、read committed（读取提交内容）。事务A对数据进行修改，但还未提交。此时开启事务B，在事务B中不能读到事务A中对数据库的修改。在事务B还没有关闭时，此时事务A提交对数据库的修改。这时候，我们在事务B中，可以查到事务A中对数据库的修改。这时存在一个问题，我们在同一个事务中，对数据库查询两次，但两次的结果是不一样的。（这种方式称为不可重复读。）\n- 3、repetition read（可重读：**默认情况下使用**）。事务A对数据进行修改，但未提交，此时开启事务B，在事务B中不能读到事务A对数据库的修改。在事务A提交对数据库修改时，此时在事务B中，仍不能读到事务A对数据库的修改。（这种方式称为可重复读）但此时有一个弊端，比如我们在事务A中对数据库增加一条数据，id 为 n ，这时候我们在事务B中查询数据，此时查不到id为n的数据。但当我们在事务B中增加id为n的数据时，系统会提示id为n的数据已经存在，我们添加失败。但此时此刻，我们在事务B中仍不能查询到id为n的数据。这种方式存在一个幻读的概念。举个例子，（系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后关闭事务发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。）\n- 4、serializable（可串行化）。在开启事务A时，会产生锁表，此时别的事务会等待，等事务A结束时才会开启。\n\n[ 1、 MySQL数据库事务的四大特性以及事务的隔离级别](https://blog.csdn.net/l1394049664/article/details/81814090)\n## 算法\n### 快排\n\n\n```java\nvoid quickSort(int[] num, int start, int end) {\n\tif (num.length == 0)\n\t\treturn;\n\tif (start >= end)\n\t\treturn;\n\n\tint low = start;\n\tint high = end;\n\tint temp = num[low];\n\twhile (low < high) {\n\t\twhile (low < high && num[high] > temp) {\n\t\t\thigh--;\n\t\t}\n\t\tnum[low] = num[high];\n\t\twhile (low < high &&num[low] <= temp) {\n\t\t\tlow++;\n\t  }\n\t   num[high] = num[low];\n\t}\n\tnum[low] = temp;\n\tquickSort(num, start, low - 1);\n\tquickSort(num, high + 1, end);\n\n}\n```\n[1、快速排序基本思想](https://blog.csdn.net/nrsc272420199/article/details/82587933)\n\n\n",[[1556469447169,["28447@DESKTOP-BE7HQ26",[[-1,7379," "]],[7380,7380],[7379,7379]]],[1556469452886,["28447@DESKTOP-BE7HQ26",[[1,7381,"："]],[7381,7381],[7382,7382]]],[1556469455417,["28447@DESKTOP-BE7HQ26",[[1,7186,"："]],[7186,7186],[7187,7187]]],[1556469663728,["28447@DESKTOP-BE7HQ26",[[-1,6868,"定长"]],[6870,6870],[6868,6868]]],[1556469663907,["28447@DESKTOP-BE7HQ26",[[1,6868," "]],[6868,6868],[6869,6869]]],[1556469669341,["28447@DESKTOP-BE7HQ26",[[1,6869,"延迟加载"]],[6869,6869],[6873,6873]]],[1556469724113,["28447@DESKTOP-BE7HQ26",[[-1,6869,"延迟"]],[6871,6871],[6869,6869]]],[1556469728799,["28447@DESKTOP-BE7HQ26",[[1,6869,"定时的"]],[6869,6869],[6872,6872]]],[1556469734102,["28447@DESKTOP-BE7HQ26",[[1,6877,"（）"]],[6877,6877],[6879,6879]]],[1556469736559,["28447@DESKTOP-BE7HQ26",[[1,6878,"此线程池支持定时以及周期性执行任务的需求"]],[6878,6878],[6898,6898]]],[1556469746401,["28447@DESKTOP-BE7HQ26",[[-1,6878,"此线程池支持"]],[6878,6884],[6878,6878]]],[1556469748547,["28447@DESKTOP-BE7HQ26",[[-1,6889,"的需求"]],[6892,6892],[6889,6889]]]],null,"28447@DESKTOP-BE7HQ26"]]}