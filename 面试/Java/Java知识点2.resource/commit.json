{"compress":true,"commitItems":[["b19f161c-8b2a-46d6-8df5-ba797c4a6c92",1554083997090,"",[[1554083942995,["28447@DESKTOP-BE7HQ26",[[1,0,"# Java知识点2\n\n\n\n"]],[0,0],[13,13]]],[1554083948673,["28447@DESKTOP-BE7HQ26",[[-1,13,"\n"],[1,14,"#"]],[13,13],[14,14]]],[1554083985853,["28447@DESKTOP-BE7HQ26",[[1,14,"# ### String、StringBuffer、StringBuilder的区别，怎么理解String不变性"]],[14,14],[70,70]]],[1554083989533,["28447@DESKTOP-BE7HQ26",[[-1,16,"### "]],[19,19],[15,15]]],[1554083991610,["28447@DESKTOP-BE7HQ26",[[1,66,"\n\n"]],[66,66],[67,67]]],[1554083998104,["28447@DESKTOP-BE7HQ26",[[-1,67,"\n"],[1,68,"-"]],[67,67],[68,68]]],[1554084003972,["28447@DESKTOP-BE7HQ26",[[1,68," 可变与不可变\n- "]],[68,68],[78,78]]],[1554084004340,["28447@DESKTOP-BE7HQ26",[[1,76,"  "]],[78,78],[80,80]]],[1554084013341,["28447@DESKTOP-BE7HQ26",[[1,80,"String dui"]],[80,80],[90,90]]],[1554084014086,["28447@DESKTOP-BE7HQ26",[[-1,87,"dui"]],[90,90],[87,87]]],[1554084015612,["28447@DESKTOP-BE7HQ26",[[1,87,"杜希昂"]],[87,87],[90,90]]],[1554084016416,["28447@DESKTOP-BE7HQ26",[[-1,87,"杜希昂"]],[90,90],[87,87]]],[1554084031534,["28447@DESKTOP-BE7HQ26",[[1,87,"对象不可变\n  - StringBuilder与StringBuffer对象可变\n  - "]],[87,87],[132,132]]],[1554084032252,["28447@DESKTOP-BE7HQ26",[[-1,128,"  - "],[1,132,"\n\n"]],[132,132],[129,129]]],[1554084032902,["28447@DESKTOP-BE7HQ26",[[-1,129,"\n"]],[129,129],[128,128]]],[1554084033904,["28447@DESKTOP-BE7HQ26",[[-1,128,"\n"],[1,129,"-"]],[128,128],[129,129]]],[1554084041526,["28447@DESKTOP-BE7HQ26",[[1,129," 是否线程安全\n- "]],[129,129],[139,139]]],[1554084042407,["28447@DESKTOP-BE7HQ26",[[1,137,"  "]],[139,139],[141,141]]],[1554084055780,["28447@DESKTOP-BE7HQ26",[[1,141,"String对象不可变，"]],[141,141],[153,153]]],[1554084084413,["28447@DESKTOP-BE7HQ26",[[1,153,"线程安全\n  - StringBuffer使用同步锁\n  - "]],[153,153],[184,184]]],[1554084090755,["28447@DESKTOP-BE7HQ26",[[1,179,"，线程安全"]],[179,179],[184,184]]],[1554084112465,["28447@DESKTOP-BE7HQ26",[[1,189,"StringBuilder线程不安全（）"]],[189,189],[209,209]]],[1554084117091,["28447@DESKTOP-BE7HQ26",[[1,208,"叙埃律"]],[208,208],[211,211]]],[1554084118185,["28447@DESKTOP-BE7HQ26",[[-1,208,"叙埃律"]],[211,211],[208,208]]],[1554084123955,["28447@DESKTOP-BE7HQ26",[[1,208,"效率高于string"]],[208,208],[218,218]]],[1554084126689,["28447@DESKTOP-BE7HQ26",[[-1,212,"string"]],[218,218],[212,212]]],[1554084131912,["28447@DESKTOP-BE7HQ26",[[1,212,"StringBuffer"]],[212,212],[224,224]]],[1554084133120,["28447@DESKTOP-BE7HQ26",[[1,225,"\n  - "]],[225,225],[230,230]]],[1554084133499,["28447@DESKTOP-BE7HQ26",[[-1,226,"  - "],[1,230,"\n\n"]],[230,230],[227,227]]],[1554084175205,["28447@DESKTOP-BE7HQ26",[[1,227,"### ==和equals的区别，如果重写了equals()不重写hashCode()会发生什么"]],[227,227],[275,275]]],[1554084176897,["28447@DESKTOP-BE7HQ26",[[-1,229,"#"]],[230,230],[229,229]]],[1554084178836,["28447@DESKTOP-BE7HQ26",[[1,275,"\n"]],[274,274],[275,275]]],[1554084179127,["28447@DESKTOP-BE7HQ26",[[1,276,"\n"]],[275,275],[276,276]]],[1554085388616,["28447@DESKTOP-BE7HQ26",[[-1,276,"\n"],[1,277,"="]],[276,276],[277,277]]],[1554085388815,["28447@DESKTOP-BE7HQ26",[[1,277,"==="]],[277,277],[278,278]]],[1554085388930,["28447@DESKTOP-BE7HQ26",[[1,278," "]],[278,278],[279,279]]],[1554085390089,["28447@DESKTOP-BE7HQ26",[[-1,278,"== "]],[279,279],[276,276]]],[1554085393076,["28447@DESKTOP-BE7HQ26",[[1,276,"****"]],[276,276],[278,278]]],[1554085394800,["28447@DESKTOP-BE7HQ26",[[-1,280,"=="]],[280,282],[280,280]]],[1554085396843,["28447@DESKTOP-BE7HQ26",[[-1,276,"****"],[1,280,"\n"]],[276,280],[276,276]]],[1554085397114,["28447@DESKTOP-BE7HQ26",[[-1,276,"\n"],[1,277,"="]],[276,276],[277,277]]],[1554085397292,["28447@DESKTOP-BE7HQ26",[[1,277,"==="]],[277,277],[278,278]]],[1554085398184,["28447@DESKTOP-BE7HQ26",[[-1,278,"=="]],[278,278],[276,276]]],[1554085402954,["28447@DESKTOP-BE7HQ26",[[1,278," : bi"]],[278,278],[283,283]]],[1554085403564,["28447@DESKTOP-BE7HQ26",[[-1,281,"bi"]],[283,283],[281,281]]],[1554085406264,["28447@DESKTOP-BE7HQ26",[[1,281,"比较的式"]],[281,281],[285,285]]],[1554085407028,["28447@DESKTOP-BE7HQ26",[[-1,284,"式"]],[285,285],[284,284]]],[1554085416122,["28447@DESKTOP-BE7HQ26",[[1,284,"是对象的地址"]],[284,284],[290,290]]],[1554085416393,["28447@DESKTOP-BE7HQ26",[[1,290,"\n\n"]],[290,290],[291,291]]],[1554085419380,["28447@DESKTOP-BE7HQ26",[[-1,291,"\n"],[1,292,"equal"]],[291,291],[296,296]]],[1554085422535,["28447@DESKTOP-BE7HQ26",[[1,296,"s："]],[296,296],[298,298]]],[1554085423514,["28447@DESKTOP-BE7HQ26",[[-1,297,"："]],[298,298],[297,297]]],[1554085423888,["28447@DESKTOP-BE7HQ26",[[1,297," "]],[297,297],[298,298]]],[1554085424496,["28447@DESKTOP-BE7HQ26",[[-1,297," "]],[298,298],[297,297]]],[1554085443362,["28447@DESKTOP-BE7HQ26",[[1,297,"：比较的是对象的内容，但假如补充些"]],[297,297],[314,314]]],[1554085444473,["28447@DESKTOP-BE7HQ26",[[-1,311,"补充些"]],[314,314],[311,311]]],[1554085448631,["28447@DESKTOP-BE7HQ26",[[1,311,"不重写"]],[311,311],[314,314]]],[1554085456092,["28447@DESKTOP-BE7HQ26",[[1,314,"equak"]],[314,314],[319,319]]],[1554085456704,["28447@DESKTOP-BE7HQ26",[[-1,318,"k"]],[319,319],[318,318]]],[1554085469242,["28447@DESKTOP-BE7HQ26",[[1,318,"ls,默认调用Objects"]],[318,318],[332,332]]],[1554085469938,["28447@DESKTOP-BE7HQ26",[[-1,331,"s"]],[332,332],[331,331]]],[1554085470997,["28447@DESKTOP-BE7HQ26",[[1,331,"ch"]],[331,331],[333,333]]],[1554085471736,["28447@DESKTOP-BE7HQ26",[[-1,331,"ch"]],[333,333],[331,331]]],[1554085474246,["28447@DESKTOP-BE7HQ26",[[1,331,"超累的"]],[331,331],[334,334]]],[1554085475135,["28447@DESKTOP-BE7HQ26",[[-1,331,"超累的"]],[334,334],[331,331]]],[1554085485302,["28447@DESKTOP-BE7HQ26",[[1,331,"超类的equak"]],[331,331],[339,339]]],[1554085485679,["28447@DESKTOP-BE7HQ26",[[-1,338,"k"]],[339,339],[338,338]]],[1554085489934,["28447@DESKTOP-BE7HQ26",[[1,338,"ls（）"]],[338,338],[342,342]]],[1554085505596,["28447@DESKTOP-BE7HQ26",[[1,341,"内部实现是“”"]],[341,341],[348,348]]],[1554085507058,["28447@DESKTOP-BE7HQ26",[[1,347,"===="]],[347,347],[349,349]]],[1554085508205,["28447@DESKTOP-BE7HQ26",[[-1,349,"=="]],[349,349],[347,347]]],[1554085512864,["28447@DESKTOP-BE7HQ26",[[1,350," 元素安抚"]],[350,350],[355,355]]],[1554085514000,["28447@DESKTOP-BE7HQ26",[[-1,352,"素安抚"]],[355,355],[352,352]]],[1554085514526,["28447@DESKTOP-BE7HQ26",[[-1,351,"元"]],[352,352],[351,351]]],[1554085521098,["28447@DESKTOP-BE7HQ26",[[1,351,"运算符"]],[351,351],[354,354]]],[1554085531495,["28447@DESKTOP-BE7HQ26",[[1,355,"\n\n"]],[355,355],[356,356]]],[1554085531703,["28447@DESKTOP-BE7HQ26",[[1,357,"\n"]],[356,356],[357,357]]],[1554086181765,["28447@DESKTOP-BE7HQ26",[[1,358,"\n"]],[355,355],[356,356]]],[1554086181991,["28447@DESKTOP-BE7HQ26",[[1,359,"\n"]],[356,356],[357,357]]],[1554086213189,["28447@DESKTOP-BE7HQ26",[[1,357,"利用HashSet/HashMap/Hashtable类存储惧时"]],[357,357],[389,389]]],[1554086215442,["28447@DESKTOP-BE7HQ26",[[-1,387,"惧"]],[388,388],[387,387]]],[1554086218146,["28447@DESKTOP-BE7HQ26",[[1,387,"数据集"]],[387,387],[390,390]]],[1554086218471,["28447@DESKTOP-BE7HQ26",[[-1,389,"集"]],[390,390],[389,389]]],[1554086246089,["28447@DESKTOP-BE7HQ26",[[1,357,"hashcode时"]],[357,357],[366,366]]],[1554086248974,["28447@DESKTOP-BE7HQ26",[[-1,365,"时"]],[366,366],[365,365]]],[1554086251069,["28447@DESKTOP-BE7HQ26",[[1,365,"是"]],[365,365],[366,366]]],[1554086257906,["28447@DESKTOP-BE7HQ26",[[-1,357,"hashcode是"]],[366,366],[357,357]]],[1554086285987,["28447@DESKTOP-BE7HQ26",[[1,390,"，都是根据存储对象的hashcode值进行判断是否相同"]],[390,390],[417,417]]],[1554086502537,["28447@DESKTOP-BE7HQ26",[[1,417,"。如果对一个"]],[417,417],[423,423]]],[1554086506124,["28447@DESKTOP-BE7HQ26",[[-1,421,"一个"]],[423,423],[421,421]]],[1554086513666,["28447@DESKTOP-BE7HQ26",[[1,421,"对象重写了equak"]],[421,421],[431,431]]],[1554086514231,["28447@DESKTOP-BE7HQ26",[[-1,430,"k"]],[431,431],[430,430]]],[1554086520796,["28447@DESKTOP-BE7HQ26",[[1,430,"ls,yi"]],[430,430],[435,435]]],[1554086521291,["28447@DESKTOP-BE7HQ26",[[-1,433,"yi"]],[435,435],[433,433]]],[1554086530882,["28447@DESKTOP-BE7HQ26",[[1,433,"意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象"]],[433,433],[492,492]]],[1554086547023,["28447@DESKTOP-BE7HQ26",[[1,492,"，当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象"]],[492,492],[578,578]]],[1554086552585,["28447@DESKTOP-BE7HQ26",[[1,357,"\n"]],[356,356],[357,357]]],[1554086559104,["28447@DESKTOP-BE7HQ26",[[1,276,"、"]],[276,276],[277,277]]],[1554086559860,["28447@DESKTOP-BE7HQ26",[[-1,276,"、"]],[277,277],[276,276]]],[1554086563579,["28447@DESKTOP-BE7HQ26",[[1,276,"answer:"]],[276,276],[283,283]]],[1554086564908,["28447@DESKTOP-BE7HQ26",[[1,282,"1"]],[282,282],[283,283]]],[1554086566021,["28447@DESKTOP-BE7HQ26",[[-1,283,":"]],[284,284],[283,283]]],[1554086567159,["28447@DESKTOP-BE7HQ26",[[1,283,":"]],[283,283],[284,284]]],[1554086567414,["28447@DESKTOP-BE7HQ26",[[1,284,"\n"]],[284,284],[285,285]]],[1554086567712,["28447@DESKTOP-BE7HQ26",[[1,285,"  "]],[285,285],[287,287]]],[1554086572853,["28447@DESKTOP-BE7HQ26",[[-1,286," "]],[287,287],[286,286]]],[1554086574035,["28447@DESKTOP-BE7HQ26",[[1,286,"- "]],[286,286],[288,288]]],[1554086577020,["28447@DESKTOP-BE7HQ26",[[1,303,"- "]],[303,303],[305,305]]],[1554086580181,["28447@DESKTOP-BE7HQ26",[[-1,286,"-"]],[287,287],[286,286]]],[1554086581500,["28447@DESKTOP-BE7HQ26",[[1,286,"-"]],[286,286],[287,287]]],[1554086584747,["28447@DESKTOP-BE7HQ26",[[1,303,"  "]],[303,303],[305,305]]],[1554086586218,["28447@DESKTOP-BE7HQ26",[[-1,304," "]],[305,305],[304,304]]],[1554086593666,["28447@DESKTOP-BE7HQ26",[[1,372,"answers2:"]],[372,372],[381,381]]],[1554086598123,["28447@DESKTOP-BE7HQ26",[[1,382,"- "]],[382,382],[384,384]]],[1554086608359,["28447@DESKTOP-BE7HQ26",[[1,605,"."]],[605,605],[606,606]]],[1554086608685,["28447@DESKTOP-BE7HQ26",[[1,607,"- \n"]],[606,606],[609,609]]],[1554086609686,["28447@DESKTOP-BE7HQ26",[[-1,607,"- "]],[609,609],[608,608]]],[1554086618199,["28447@DESKTOP-BE7HQ26",[[-1,0,"# Java知识点2\n\n\n## String、StringBuffer、StringBuilder的区别，怎么理解String不变性\n- 可变与不可变\n  - String 对象不可变\n  - StringBuilder与StringBuffer对象可变\n- 是否线程安全\n  - String对象不可变，线程安全\n  - StringBuffer使用同步锁，线程安全\n  - StringBuilder线程不安全（效率高于StringBuffer）\n\n## ==和equals的区别，如果重写了equals()不重写hashCode()会发生什么\n\nanswer1:\n - == : 比较的是对象的地址\n - equals：比较的是对象的内容，但假如不重写equals,默认调用Object超类的equals（内部实现是“==” 运算符）\n\nanswers2:\n- 利用HashSet/HashMap/Hashtable类存储数据时，都是根据存储对象的hashcode值进行判断是否相同。如果对对象重写了equals,意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象，当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象.\n\n\n\n"]],[0,610],[0,0]]],[1554086619424,["28447@DESKTOP-BE7HQ26",[[1,0,"# Java知识点2\n\n\n## String、StringBuffer、StringBuilder的区别，怎么理解String不变性\n- 可变与不可变\n  - String 对象不可变\n  - StringBuilder与StringBuffer对象可变\n- 是否线程安全\n  - String对象不可变，线程安全\n  - StringBuffer使用同步锁，线程安全\n  - StringBuilder线程不安全（效率高于StringBuffer）\n\n## ==和equals的区别，如果重写了equals()不重写hashCode()会发生什么\n\nanswer1:\n - == : 比较的是对象的地址\n - equals：比较的是对象的内容，但假如不重写equals,默认调用Object超类的equals（内部实现是“==” 运算符）\n\nanswers2:\n- 利用HashSet/HashMap/Hashtable类存储数据时，都是根据存储对象的hashcode值进行判断是否相同。如果对对象重写了equals,意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象，当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象.\n\n\n\n"]],[0,0],[0,610]]],[1554086624554,["28447@DESKTOP-BE7HQ26",[[1,607,"- \n"]],[606,606],[609,609]]],[1554086624770,["28447@DESKTOP-BE7HQ26",[[-1,607,"- "]],[609,609],[608,608]]],[1554086634350,["28447@DESKTOP-BE7HQ26",[[-1,610,"\n"]],[608,608],[607,607]]],[1554086634983,["28447@DESKTOP-BE7HQ26",[[1,610,"\n"]],[607,607],[608,608]]],[1554086635865,["28447@DESKTOP-BE7HQ26",[[-1,610,"\n"]],[608,608],[607,607]]],[1554086636578,["28447@DESKTOP-BE7HQ26",[[1,610,"\n"]],[607,607],[608,608]]],[1554086637484,["28447@DESKTOP-BE7HQ26",[[1,608,"zong"]],[608,608],[612,612]]],[1554086638377,["28447@DESKTOP-BE7HQ26",[[-1,608,"zong"]],[612,612],[608,608]]],[1554086642118,["28447@DESKTOP-BE7HQ26",[[1,608,"总结关系："]],[608,608],[613,613]]],[1554086647357,["28447@DESKTOP-BE7HQ26",[[1,610,"equal"]],[610,610],[615,615]]],[1554086647989,["28447@DESKTOP-BE7HQ26",[[-1,614,"l"]],[615,615],[614,614]]],[1554086648763,["28447@DESKTOP-BE7HQ26",[[1,614,"ls"]],[614,614],[616,616]]],[1554086651533,["28447@DESKTOP-BE7HQ26",[[1,610,"cho"]],[610,610],[613,613]]],[1554086652295,["28447@DESKTOP-BE7HQ26",[[-1,610,"cho"]],[613,613],[610,610]]],[1554086653954,["28447@DESKTOP-BE7HQ26",[[1,610,"重写"]],[610,610],[612,612]]],[1554086669138,["28447@DESKTOP-BE7HQ26",[[1,618,"和重写hashcode()"]],[618,618],[631,631]]],[1554086674805,["28447@DESKTOP-BE7HQ26",[[1,618,"()"]],[618,618],[620,620]]],[1554086678000,["28447@DESKTOP-BE7HQ26",[[1,637,"1、如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；\n\n2、如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)"]],[637,637],[735,735]]],[1554086680266,["28447@DESKTOP-BE7HQ26",[[1,637,"- "]],[637,637],[639,639]]],[1554086682412,["28447@DESKTOP-BE7HQ26",[[1,690,"- "]],[690,690],[692,692]]],[1554086686124,["28447@DESKTOP-BE7HQ26",[[1,306,"\n - "]],[302,302],[306,306]]],[1554086687558,["28447@DESKTOP-BE7HQ26",[[-1,304,"- "]],[306,306],[304,304]]],[1554086690356,["28447@DESKTOP-BE7HQ26",[[1,742,"- \n"]],[741,741],[744,744]]],[1554086690575,["28447@DESKTOP-BE7HQ26",[[-1,742,"- "]],[744,744],[743,743]]],[1554086690775,["28447@DESKTOP-BE7HQ26",[[1,744,"\n"]],[743,743],[744,744]]],[1554086904516,["28447@DESKTOP-BE7HQ26",[[1,742,"- \n"]],[741,741],[744,744]]],[1554086904887,["28447@DESKTOP-BE7HQ26",[[-1,742,"- "]],[744,744],[743,743]]],[1554086905860,["28447@DESKTOP-BE7HQ26",[[1,746,"\n"]],[743,743],[744,744]]]],null,"28447@DESKTOP-BE7HQ26"],["1d5267d6-e86e-4738-88ab-dd6fb6c6dd7e",1554880040803,"# Java知识点2\n\n\n## String、StringBuffer、StringBuilder的区别，怎么理解String不变性\n- 可变与不可变\n  - String 对象不可变\n  - StringBuilder与StringBuffer对象可变\n- 是否线程安全\n  - String对象不可变，线程安全\n  - StringBuffer使用同步锁，线程安全\n  - StringBuilder线程不安全（效率高于StringBuffer）\n\n## ==和equals的区别，如果重写了equals()不重写hashCode()会发生什么\n\nanswer1:\n - == : 比较的是对象的地址\n \n - equals：比较的是对象的内容，但假如不重写equals,默认调用Object超类的equals（内部实现是“==” 运算符）\n\nanswers2:\n- 利用HashSet/HashMap/Hashtable类存储数据时，都是根据存储对象的hashcode值进行判断是否相同。如果对对象重写了equals,意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象，当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象.\n\n总结重写equals()和重写hashcode()关系：\n- 1、如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；\n\n- 2、如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)\n\n\n\n\n\n",[[1554880016261,["28447@DESKTOP-BE7HQ26",[[1,384,"\n"]],[383,383],[384,384]]],[1554880016435,["28447@DESKTOP-BE7HQ26",[[1,385,"\n"]],[384,384],[385,385]]],[1554880016622,["28447@DESKTOP-BE7HQ26",[[1,386,"\n"]],[385,385],[386,386]]],[1554880016799,["28447@DESKTOP-BE7HQ26",[[1,387,"\n"]],[386,386],[387,387]]],[1554880016980,["28447@DESKTOP-BE7HQ26",[[1,388,"\n"]],[387,387],[388,388]]],[1554880020009,["28447@DESKTOP-BE7HQ26",[[1,384,"- **1、重写equals方法时需要重写hashCode方法，主要是针对Map、Set等集合类型的使用；**\n\na: Map、Set等集合类型存放的对象必须是唯一的；\n\nb: 集合类判断两个对象是否相等，是先判断equals是否相等，如果equals返回TRUE，还要再判断HashCode返回值是否ture,只有两者都返回ture,才认为该两个对象是相等的。\n\n2、由于Object的hashCode返回的是对象的hash值，所以即使equals返回TRUE，集合也可能判定两个对象不等，所以必须重写hashCode方法，以保证当equals返回TRUE时，hashCode也返回Ture，这样才能使得集合中存放的对象唯一。"]],[384,384],[698,698]]],[1554880026478,["28447@DESKTOP-BE7HQ26",[[-1,703,"- 利用HashSet/HashMap/Hashtable类存储数据时，都是根据存储对象的hashcode值进行判断是否相同。如果对对象重写了equals,意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象，当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象."]],[703,927],[703,703]]],[1554880027256,["28447@DESKTOP-BE7HQ26",[[-1,704,"\n"]],[703,703],[702,702]]],[1554880027569,["28447@DESKTOP-BE7HQ26",[[-1,703,"\n"]],[702,702],[701,701]]],[1554880027840,["28447@DESKTOP-BE7HQ26",[[-1,702,"\n"]],[701,701],[700,700]]],[1554880047062,["28447@DESKTOP-BE7HQ26",[[-1,385," "]],[385,385],[385,385]]],[1554880053383,["28447@DESKTOP-BE7HQ26",[[-1,384,"-*"]],[385,385],[384,384]]],[1554880053818,["28447@DESKTOP-BE7HQ26",[[1,385,"*"]],[384,384],[385,385]]]],null,"28447@DESKTOP-BE7HQ26"],["807e8868-eccd-47ec-81cf-1f435cb92e71",1569042008263,"# Java知识点2\n\n\n## String、StringBuffer、StringBuilder的区别，怎么理解String不变性\n- 可变与不可变\n  - String 对象不可变\n  - StringBuilder与StringBuffer对象可变\n- 是否线程安全\n  - String对象不可变，线程安全\n  - StringBuffer使用同步锁，线程安全\n  - StringBuilder线程不安全（效率高于StringBuffer）\n\n## ==和equals的区别，如果重写了equals()不重写hashCode()会发生什么\n\nanswer1:\n - == : 比较的是对象的地址\n \n - equals：比较的是对象的内容，但假如不重写equals,默认调用Object超类的equals（内部实现是“==” 运算符）\n\nanswers2:\n**1、重写equals方法时需要重写hashCode方法，主要是针对Map、Set等集合类型的使用；**\n\na: Map、Set等集合类型存放的对象必须是唯一的；\n\nb: 集合类判断两个对象是否相等，是先判断equals是否相等，如果equals返回TRUE，还要再判断HashCode返回值是否ture,只有两者都返回ture,才认为该两个对象是相等的。\n\n2、由于Object的hashCode返回的是对象的hash值，所以即使equals返回TRUE，集合也可能判定两个对象不等，所以必须重写hashCode方法，以保证当equals返回TRUE时，hashCode也返回Ture，这样才能使得集合中存放的对象唯一。\n\n\n\n总结重写equals()和重写hashcode()关系：\n- 1、如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；\n\n- 2、如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)\n\n\n\n\n\n",[[1569041973717,["28447@DESKTOP-BE7HQ26",[[1,300,"内存"]],[300,300],[302,302]]],[1569042048478,["28447@DESKTOP-BE7HQ26",[[1,304,"，用来判断是否是"]],[304,304],[312,312]]],[1569042050546,["28447@DESKTOP-BE7HQ26",[[-1,311,"是"]],[312,312],[311,311]]],[1569042055127,["28447@DESKTOP-BE7HQ26",[[1,309,"两个对象"]],[309,309],[313,313]]],[1569042063118,["28447@DESKTOP-BE7HQ26",[[1,315,"是同一个对象"]],[315,315],[321,321]]]],null,"28447@DESKTOP-BE7HQ26"]]}